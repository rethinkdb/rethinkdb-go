////////////////////////////////////////////////////////////////////////////////
//                            THE HIGH-LEVEL VIEW                             //
////////////////////////////////////////////////////////////////////////////////

// Process: When you first open a connection, send the magic number
// for the version of the protobuf you're targeting (in the [Version]
// enum).  This should **NOT** be sent as a protobuf; just send the
// little-endian 32-bit integer over the wire raw.  This number should
// only be sent once per connection.

// The magic number shall be followed by an authorization key.  The
// first 4 bytes are the length of the key to be sent as a little-endian
// 32-bit integer, followed by the key string.  Even if there is no key,
// an empty string should be sent (length 0 and no data).

// Following the authorization key, the client shall send a magic number
// for the communication protocol they want to use (in the [Protocol]
// enum).  This shall be a little-endian 32-bit integer.

// The server will then respond with a NULL-terminated string response.
// "SUCCESS" indicates that the connection has been accepted. Any other
// response indicates an error, and the response string should describe
// the error.

// Next, for each query you want to send, construct a [Query] protobuf
// and serialize it to a binary blob.  Send the blob's size to the
// server encoded as a little-endian 32-bit integer, followed by the
// blob itself.  You will receive a [Response] protobuf back preceded
// by its own size, once again encoded as a little-endian 32-bit
// integer.  You can see an example exchange below in **EXAMPLE**.

// A query consists of a [Term] to evaluate and a unique-per-connection
// [token].

// Tokens are used for two things:
// * Keeping track of which responses correspond to which queries.
// * Batched queries.  Some queries return lots of results, so we send back
//   batches of <1000, and you need to send a [CONTINUE] query with the same
//   token to get more results from the original query.
////////////////////////////////////////////////////////////////////////////////

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.1
// 	protoc        v3.21.12
// source: ql2.proto

package ql2

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// non-conforming protobuf libraries
// This enum contains the magic numbers for your version.  See **THE HIGH-LEVEL
// VIEW** for what to do with it.
type VersionDummy_Version int32

const (
	VersionDummy_V0_1 VersionDummy_Version = 1063369270
	VersionDummy_V0_2 VersionDummy_Version = 1915781601 // Authorization key during handshake
	VersionDummy_V0_3 VersionDummy_Version = 1601562686 // Authorization key and protocol during handshake
	VersionDummy_V0_4 VersionDummy_Version = 1074539808 // Queries execute in parallel
	VersionDummy_V1_0 VersionDummy_Version = 885177795  // Users and permissions
)

// Enum value maps for VersionDummy_Version.
var (
	VersionDummy_Version_name = map[int32]string{
		1063369270: "V0_1",
		1915781601: "V0_2",
		1601562686: "V0_3",
		1074539808: "V0_4",
		885177795:  "V1_0",
	}
	VersionDummy_Version_value = map[string]int32{
		"V0_1": 1063369270,
		"V0_2": 1915781601,
		"V0_3": 1601562686,
		"V0_4": 1074539808,
		"V1_0": 885177795,
	}
)

func (x VersionDummy_Version) Enum() *VersionDummy_Version {
	p := new(VersionDummy_Version)
	*p = x
	return p
}

func (x VersionDummy_Version) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VersionDummy_Version) Descriptor() protoreflect.EnumDescriptor {
	return file_ql2_proto_enumTypes[0].Descriptor()
}

func (VersionDummy_Version) Type() protoreflect.EnumType {
	return &file_ql2_proto_enumTypes[0]
}

func (x VersionDummy_Version) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *VersionDummy_Version) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = VersionDummy_Version(num)
	return nil
}

// Deprecated: Use VersionDummy_Version.Descriptor instead.
func (VersionDummy_Version) EnumDescriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{0, 0}
}

// The protocol to use after the handshake, specified in V0_3
type VersionDummy_Protocol int32

const (
	VersionDummy_PROTOBUF VersionDummy_Protocol = 656407617
	VersionDummy_JSON     VersionDummy_Protocol = 2120839367
)

// Enum value maps for VersionDummy_Protocol.
var (
	VersionDummy_Protocol_name = map[int32]string{
		656407617:  "PROTOBUF",
		2120839367: "JSON",
	}
	VersionDummy_Protocol_value = map[string]int32{
		"PROTOBUF": 656407617,
		"JSON":     2120839367,
	}
)

func (x VersionDummy_Protocol) Enum() *VersionDummy_Protocol {
	p := new(VersionDummy_Protocol)
	*p = x
	return p
}

func (x VersionDummy_Protocol) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VersionDummy_Protocol) Descriptor() protoreflect.EnumDescriptor {
	return file_ql2_proto_enumTypes[1].Descriptor()
}

func (VersionDummy_Protocol) Type() protoreflect.EnumType {
	return &file_ql2_proto_enumTypes[1]
}

func (x VersionDummy_Protocol) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *VersionDummy_Protocol) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = VersionDummy_Protocol(num)
	return nil
}

// Deprecated: Use VersionDummy_Protocol.Descriptor instead.
func (VersionDummy_Protocol) EnumDescriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{0, 1}
}

type Query_QueryType int32

const (
	Query_START    Query_QueryType = 1 // Start a new query.
	Query_CONTINUE Query_QueryType = 2 // Continue a query that returned [SUCCESS_PARTIAL]
	// (see [Response]).
	Query_STOP         Query_QueryType = 3 // Stop a query partway through executing.
	Query_NOREPLY_WAIT Query_QueryType = 4 // Wait for noreply operations to finish.
	Query_SERVER_INFO  Query_QueryType = 5 // Get server information.
)

// Enum value maps for Query_QueryType.
var (
	Query_QueryType_name = map[int32]string{
		1: "START",
		2: "CONTINUE",
		3: "STOP",
		4: "NOREPLY_WAIT",
		5: "SERVER_INFO",
	}
	Query_QueryType_value = map[string]int32{
		"START":        1,
		"CONTINUE":     2,
		"STOP":         3,
		"NOREPLY_WAIT": 4,
		"SERVER_INFO":  5,
	}
)

func (x Query_QueryType) Enum() *Query_QueryType {
	p := new(Query_QueryType)
	*p = x
	return p
}

func (x Query_QueryType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Query_QueryType) Descriptor() protoreflect.EnumDescriptor {
	return file_ql2_proto_enumTypes[2].Descriptor()
}

func (Query_QueryType) Type() protoreflect.EnumType {
	return &file_ql2_proto_enumTypes[2]
}

func (x Query_QueryType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Query_QueryType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Query_QueryType(num)
	return nil
}

// Deprecated: Use Query_QueryType.Descriptor instead.
func (Query_QueryType) EnumDescriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{1, 0}
}

type Frame_FrameType int32

const (
	Frame_POS Frame_FrameType = 1 // Error occurred in a positional argument.
	Frame_OPT Frame_FrameType = 2 // Error occurred in an optional argument.
)

// Enum value maps for Frame_FrameType.
var (
	Frame_FrameType_name = map[int32]string{
		1: "POS",
		2: "OPT",
	}
	Frame_FrameType_value = map[string]int32{
		"POS": 1,
		"OPT": 2,
	}
)

func (x Frame_FrameType) Enum() *Frame_FrameType {
	p := new(Frame_FrameType)
	*p = x
	return p
}

func (x Frame_FrameType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Frame_FrameType) Descriptor() protoreflect.EnumDescriptor {
	return file_ql2_proto_enumTypes[3].Descriptor()
}

func (Frame_FrameType) Type() protoreflect.EnumType {
	return &file_ql2_proto_enumTypes[3]
}

func (x Frame_FrameType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Frame_FrameType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Frame_FrameType(num)
	return nil
}

// Deprecated: Use Frame_FrameType.Descriptor instead.
func (Frame_FrameType) EnumDescriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{2, 0}
}

type Response_ResponseType int32

const (
	// These response types indicate success.
	Response_SUCCESS_ATOM     Response_ResponseType = 1 // Query returned a single RQL datatype.
	Response_SUCCESS_SEQUENCE Response_ResponseType = 2 // Query returned a sequence of RQL datatypes.
	Response_SUCCESS_PARTIAL  Response_ResponseType = 3 // Query returned a partial sequence of RQL
	// datatypes.  If you send a [CONTINUE] query with
	// the same token as this response, you will get
	// more of the sequence.  Keep sending [CONTINUE]
	// queries until you get back [SUCCESS_SEQUENCE].
	Response_WAIT_COMPLETE Response_ResponseType = 4 // A [NOREPLY_WAIT] query completed.
	Response_SERVER_INFO   Response_ResponseType = 5 // The data for a [SERVER_INFO] request.  This is
	// These response types indicate failure.
	Response_CLIENT_ERROR Response_ResponseType = 16 // Means the client is buggy.  An example is if the
	// client sends a malformed protobuf, or tries to
	// send [CONTINUE] for an unknown token.
	Response_COMPILE_ERROR Response_ResponseType = 17 // Means the query failed during parsing or type
	// checking.  For example, if you pass too many
	// arguments to a function.
	Response_RUNTIME_ERROR Response_ResponseType = 18 // Means the query failed at runtime.  An example is
)

// Enum value maps for Response_ResponseType.
var (
	Response_ResponseType_name = map[int32]string{
		1:  "SUCCESS_ATOM",
		2:  "SUCCESS_SEQUENCE",
		3:  "SUCCESS_PARTIAL",
		4:  "WAIT_COMPLETE",
		5:  "SERVER_INFO",
		16: "CLIENT_ERROR",
		17: "COMPILE_ERROR",
		18: "RUNTIME_ERROR",
	}
	Response_ResponseType_value = map[string]int32{
		"SUCCESS_ATOM":     1,
		"SUCCESS_SEQUENCE": 2,
		"SUCCESS_PARTIAL":  3,
		"WAIT_COMPLETE":    4,
		"SERVER_INFO":      5,
		"CLIENT_ERROR":     16,
		"COMPILE_ERROR":    17,
		"RUNTIME_ERROR":    18,
	}
)

func (x Response_ResponseType) Enum() *Response_ResponseType {
	p := new(Response_ResponseType)
	*p = x
	return p
}

func (x Response_ResponseType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Response_ResponseType) Descriptor() protoreflect.EnumDescriptor {
	return file_ql2_proto_enumTypes[4].Descriptor()
}

func (Response_ResponseType) Type() protoreflect.EnumType {
	return &file_ql2_proto_enumTypes[4]
}

func (x Response_ResponseType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Response_ResponseType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Response_ResponseType(num)
	return nil
}

// Deprecated: Use Response_ResponseType.Descriptor instead.
func (Response_ResponseType) EnumDescriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{4, 0}
}

// If `ResponseType` is `RUNTIME_ERROR`, this may be filled in with more
// information about the error.
type Response_ErrorType int32

const (
	Response_INTERNAL         Response_ErrorType = 1000000
	Response_RESOURCE_LIMIT   Response_ErrorType = 2000000
	Response_QUERY_LOGIC      Response_ErrorType = 3000000
	Response_NON_EXISTENCE    Response_ErrorType = 3100000
	Response_OP_FAILED        Response_ErrorType = 4100000
	Response_OP_INDETERMINATE Response_ErrorType = 4200000
	Response_USER             Response_ErrorType = 5000000
	Response_PERMISSION_ERROR Response_ErrorType = 6000000
)

// Enum value maps for Response_ErrorType.
var (
	Response_ErrorType_name = map[int32]string{
		1000000: "INTERNAL",
		2000000: "RESOURCE_LIMIT",
		3000000: "QUERY_LOGIC",
		3100000: "NON_EXISTENCE",
		4100000: "OP_FAILED",
		4200000: "OP_INDETERMINATE",
		5000000: "USER",
		6000000: "PERMISSION_ERROR",
	}
	Response_ErrorType_value = map[string]int32{
		"INTERNAL":         1000000,
		"RESOURCE_LIMIT":   2000000,
		"QUERY_LOGIC":      3000000,
		"NON_EXISTENCE":    3100000,
		"OP_FAILED":        4100000,
		"OP_INDETERMINATE": 4200000,
		"USER":             5000000,
		"PERMISSION_ERROR": 6000000,
	}
)

func (x Response_ErrorType) Enum() *Response_ErrorType {
	p := new(Response_ErrorType)
	*p = x
	return p
}

func (x Response_ErrorType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Response_ErrorType) Descriptor() protoreflect.EnumDescriptor {
	return file_ql2_proto_enumTypes[5].Descriptor()
}

func (Response_ErrorType) Type() protoreflect.EnumType {
	return &file_ql2_proto_enumTypes[5]
}

func (x Response_ErrorType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Response_ErrorType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Response_ErrorType(num)
	return nil
}

// Deprecated: Use Response_ErrorType.Descriptor instead.
func (Response_ErrorType) EnumDescriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{4, 1}
}

// ResponseNotes are used to provide information about the query
// response that may be useful for people writing drivers or ORMs.
// Currently all the notes we send indicate that a stream has certain
// special properties.
type Response_ResponseNote int32

const (
	// The stream is a changefeed stream (e.g. `r.table('test').changes()`).
	Response_SEQUENCE_FEED Response_ResponseNote = 1
	// The stream is a point changefeed stream
	// (e.g. `r.table('test').get(0).changes()`).
	Response_ATOM_FEED Response_ResponseNote = 2
	// The stream is an order_by_limit changefeed stream
	// (e.g. `r.table('test').order_by(index: 'id').limit(5).changes()`).
	Response_ORDER_BY_LIMIT_FEED Response_ResponseNote = 3
	// The stream is a union of multiple changefeed types that can't be
	// collapsed to a single type
	// (e.g. `r.table('test').changes().union(r.table('test').get(0).changes())`).
	Response_UNIONED_FEED Response_ResponseNote = 4
	// The stream is a changefeed stream and includes notes on what state
	// the changefeed stream is in (e.g. objects of the form `{state:
	// 'initializing'}`).
	Response_INCLUDES_STATES Response_ResponseNote = 5
)

// Enum value maps for Response_ResponseNote.
var (
	Response_ResponseNote_name = map[int32]string{
		1: "SEQUENCE_FEED",
		2: "ATOM_FEED",
		3: "ORDER_BY_LIMIT_FEED",
		4: "UNIONED_FEED",
		5: "INCLUDES_STATES",
	}
	Response_ResponseNote_value = map[string]int32{
		"SEQUENCE_FEED":       1,
		"ATOM_FEED":           2,
		"ORDER_BY_LIMIT_FEED": 3,
		"UNIONED_FEED":        4,
		"INCLUDES_STATES":     5,
	}
)

func (x Response_ResponseNote) Enum() *Response_ResponseNote {
	p := new(Response_ResponseNote)
	*p = x
	return p
}

func (x Response_ResponseNote) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Response_ResponseNote) Descriptor() protoreflect.EnumDescriptor {
	return file_ql2_proto_enumTypes[6].Descriptor()
}

func (Response_ResponseNote) Type() protoreflect.EnumType {
	return &file_ql2_proto_enumTypes[6]
}

func (x Response_ResponseNote) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Response_ResponseNote) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Response_ResponseNote(num)
	return nil
}

// Deprecated: Use Response_ResponseNote.Descriptor instead.
func (Response_ResponseNote) EnumDescriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{4, 2}
}

type Datum_DatumType int32

const (
	Datum_R_NULL   Datum_DatumType = 1
	Datum_R_BOOL   Datum_DatumType = 2
	Datum_R_NUM    Datum_DatumType = 3 // a double
	Datum_R_STR    Datum_DatumType = 4
	Datum_R_ARRAY  Datum_DatumType = 5
	Datum_R_OBJECT Datum_DatumType = 6
	// This [DatumType] will only be used if [accepts_r_json] is
	// set to [true] in [Query].  [r_str] will be filled with a
	// JSON encoding of the [Datum].
	Datum_R_JSON Datum_DatumType = 7 // uses r_str
)

// Enum value maps for Datum_DatumType.
var (
	Datum_DatumType_name = map[int32]string{
		1: "R_NULL",
		2: "R_BOOL",
		3: "R_NUM",
		4: "R_STR",
		5: "R_ARRAY",
		6: "R_OBJECT",
		7: "R_JSON",
	}
	Datum_DatumType_value = map[string]int32{
		"R_NULL":   1,
		"R_BOOL":   2,
		"R_NUM":    3,
		"R_STR":    4,
		"R_ARRAY":  5,
		"R_OBJECT": 6,
		"R_JSON":   7,
	}
)

func (x Datum_DatumType) Enum() *Datum_DatumType {
	p := new(Datum_DatumType)
	*p = x
	return p
}

func (x Datum_DatumType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Datum_DatumType) Descriptor() protoreflect.EnumDescriptor {
	return file_ql2_proto_enumTypes[7].Descriptor()
}

func (Datum_DatumType) Type() protoreflect.EnumType {
	return &file_ql2_proto_enumTypes[7]
}

func (x Datum_DatumType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Datum_DatumType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Datum_DatumType(num)
	return nil
}

// Deprecated: Use Datum_DatumType.Descriptor instead.
func (Datum_DatumType) EnumDescriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{5, 0}
}

type Term_TermType int32

const (
	// A RQL datum, stored in `datum` below.
	Term_DATUM      Term_TermType = 1
	Term_MAKE_ARRAY Term_TermType = 2 // DATUM... -> ARRAY
	// Evaluate the terms in [optargs] and make an object
	Term_MAKE_OBJ Term_TermType = 3 // {...} -> OBJECT
	// Takes an integer representing a variable and returns the value stored
	// in that variable.  It's the responsibility of the client to translate
	// from their local representation of a variable to a unique _non-negative_
	// integer for that variable.  (We do it this way instead of letting
	// clients provide variable names as strings to discourage
	// variable-capturing client libraries, and because it's more efficient
	// on the wire.)
	Term_VAR Term_TermType = 10 // !NUMBER -> DATUM
	// Takes some javascript code and executes it.
	Term_JAVASCRIPT Term_TermType = 11 // STRING {timeout: !NUMBER} -> DATUM |
	// STRING {timeout: !NUMBER} -> Function(*)
	Term_UUID Term_TermType = 169 // () -> DATUM
	// Takes an HTTP URL and gets it.  If the get succeeds and
	//  returns valid JSON, it is converted into a DATUM
	Term_HTTP Term_TermType = 153 // STRING {data: OBJECT | STRING,
	// Takes a string and throws an error with that message.
	// Inside of a `default` block, you can omit the first
	// argument to rethrow whatever error you catch (this is most
	// useful as an argument to the `default` filter optarg).
	Term_ERROR Term_TermType = 12 // STRING -> Error | -> Error
	// Takes nothing and returns a reference to the implicit variable.
	Term_IMPLICIT_VAR Term_TermType = 13 // -> DATUM
	// * Data Operators
	// Returns a reference to a database.
	Term_DB Term_TermType = 14 // STRING -> Database
	// Returns a reference to a table.
	Term_TABLE Term_TermType = 15 // Database, STRING, {read_mode:STRING, identifier_format:STRING} -> Table
	// STRING, {read_mode:STRING, identifier_format:STRING} -> Table
	// Gets a single element from a table by its primary or a secondary key.
	Term_GET Term_TermType = 16 // Table, STRING -> SingleSelection | Table, NUMBER -> SingleSelection |
	// Table, STRING -> NULL            | Table, NUMBER -> NULL |
	Term_GET_ALL Term_TermType = 78 // Table, DATUM..., {index:!STRING} => ARRAY
	// Simple DATUM Ops
	Term_EQ  Term_TermType = 17 // DATUM... -> BOOL
	Term_NE  Term_TermType = 18 // DATUM... -> BOOL
	Term_LT  Term_TermType = 19 // DATUM... -> BOOL
	Term_LE  Term_TermType = 20 // DATUM... -> BOOL
	Term_GT  Term_TermType = 21 // DATUM... -> BOOL
	Term_GE  Term_TermType = 22 // DATUM... -> BOOL
	Term_NOT Term_TermType = 23 // BOOL -> BOOL
	// ADD can either add two numbers or concatenate two arrays.
	Term_ADD   Term_TermType = 24  // NUMBER... -> NUMBER | STRING... -> STRING
	Term_SUB   Term_TermType = 25  // NUMBER... -> NUMBER
	Term_MUL   Term_TermType = 26  // NUMBER... -> NUMBER
	Term_DIV   Term_TermType = 27  // NUMBER... -> NUMBER
	Term_MOD   Term_TermType = 28  // NUMBER, NUMBER -> NUMBER
	Term_FLOOR Term_TermType = 183 // NUMBER -> NUMBER
	Term_CEIL  Term_TermType = 184 // NUMBER -> NUMBER
	Term_ROUND Term_TermType = 185 // NUMBER -> NUMBER
	// DATUM Array Ops
	// Append a single element to the end of an array (like `snoc`).
	Term_APPEND Term_TermType = 29 // ARRAY, DATUM -> ARRAY
	// Prepend a single element to the end of an array (like `cons`).
	Term_PREPEND Term_TermType = 80 // ARRAY, DATUM -> ARRAY
	//Remove the elements of one array from another array.
	Term_DIFFERENCE Term_TermType = 95 // ARRAY, ARRAY -> ARRAY
	// DATUM Set Ops
	// Set ops work on arrays. They don't use actual sets and thus have
	// performance characteristics you would expect from arrays rather than
	// from sets. All set operations have the post condition that they
	// array they return contains no duplicate values.
	Term_SET_INSERT       Term_TermType = 88 // ARRAY, DATUM -> ARRAY
	Term_SET_INTERSECTION Term_TermType = 89 // ARRAY, ARRAY -> ARRAY
	Term_SET_UNION        Term_TermType = 90 // ARRAY, ARRAY -> ARRAY
	Term_SET_DIFFERENCE   Term_TermType = 91 // ARRAY, ARRAY -> ARRAY
	Term_SLICE            Term_TermType = 30 // Sequence, NUMBER, NUMBER -> Sequence
	Term_SKIP             Term_TermType = 70 // Sequence, NUMBER -> Sequence
	Term_LIMIT            Term_TermType = 71 // Sequence, NUMBER -> Sequence
	Term_OFFSETS_OF       Term_TermType = 87 // Sequence, DATUM -> Sequence | Sequence, Function(1) -> Sequence
	Term_CONTAINS         Term_TermType = 93 // Sequence, (DATUM | Function(1))... -> BOOL
	// Stream/Object Ops
	// Get a particular field from an object, or map that over a
	// sequence.
	Term_GET_FIELD Term_TermType = 31 // OBJECT, STRING -> DATUM
	// | Sequence, STRING -> Sequence
	// Return an array containing the keys of the object.
	Term_KEYS Term_TermType = 94 // OBJECT -> ARRAY
	// Return an array containing the values of the object.
	Term_VALUES Term_TermType = 186 // OBJECT -> ARRAY
	// Creates an object
	Term_OBJECT Term_TermType = 143 // STRING, DATUM, ... -> OBJECT
	// Check whether an object contains all the specified fields,
	// or filters a sequence so that all objects inside of it
	// contain all the specified fields.
	Term_HAS_FIELDS Term_TermType = 32 // OBJECT, Pathspec... -> BOOL
	// x.with_fields(...) <=> x.has_fields(...).pluck(...)
	Term_WITH_FIELDS Term_TermType = 96 // Sequence, Pathspec... -> Sequence
	// Get a subset of an object by selecting some attributes to preserve,
	// or map that over a sequence.  (Both pick and pluck, polymorphic.)
	Term_PLUCK Term_TermType = 33 // Sequence, Pathspec... -> Sequence | OBJECT, Pathspec... -> OBJECT
	// Get a subset of an object by selecting some attributes to discard, or
	// map that over a sequence.  (Both unpick and without, polymorphic.)
	Term_WITHOUT Term_TermType = 34 // Sequence, Pathspec... -> Sequence | OBJECT, Pathspec... -> OBJECT
	// Merge objects (right-preferential)
	Term_MERGE Term_TermType = 35 // OBJECT... -> OBJECT | Sequence -> Sequence
	// Sequence Ops
	// Get all elements of a sequence between two values.
	// Half-open by default, but the openness of either side can be
	// changed by passing 'closed' or 'open for `right_bound` or
	// `left_bound`.
	Term_BETWEEN_DEPRECATED Term_TermType = 36 // Deprecated version of between, which allows `null` to specify unboundedness
	// With the newer version, clients should use `r.minval` and `r.maxval` for unboundedness
	Term_BETWEEN Term_TermType = 182 // StreamSelection, DATUM, DATUM, {index:!STRING, right_bound:STRING, left_bound:STRING} -> StreamSelection
	Term_REDUCE  Term_TermType = 37  // Sequence, Function(2) -> DATUM
	Term_MAP     Term_TermType = 38  // Sequence, Function(1) -> Sequence
	Term_FOLD    Term_TermType = 187 // Sequence, Datum, Function(2), {Function(3), Function(1)
	// Filter a sequence with either a function or a shortcut
	// object (see API docs for details).  The body of FILTER is
	// wrapped in an implicit `.default(false)`, and you can
	// change the default value by specifying the `default`
	// optarg.  If you make the default `r.error`, all errors
	// caught by `default` will be rethrown as if the `default`
	// did not exist.
	Term_FILTER Term_TermType = 39 // Sequence, Function(1), {default:DATUM} -> Sequence |
	// Sequence, OBJECT, {default:DATUM} -> Sequence
	// Map a function over a sequence and then concatenate the results together.
	Term_CONCAT_MAP Term_TermType = 40 // Sequence, Function(1) -> Sequence
	// Order a sequence based on one or more attributes.
	Term_ORDER_BY Term_TermType = 41 // Sequence, (!STRING | Ordering)..., {index: (!STRING | Ordering)} -> Sequence
	// Get all distinct elements of a sequence (like `uniq`).
	Term_DISTINCT Term_TermType = 42 // Sequence -> Sequence
	// Count the number of elements in a sequence, or only the elements that match
	// a given filter.
	Term_COUNT    Term_TermType = 43 // Sequence -> NUMBER | Sequence, DATUM -> NUMBER | Sequence, Function(1) -> NUMBER
	Term_IS_EMPTY Term_TermType = 86 // Sequence -> BOOL
	// Take the union of multiple sequences (preserves duplicate elements! (use distinct)).
	Term_UNION Term_TermType = 44 // Sequence... -> Sequence
	// Get the Nth element of a sequence.
	Term_NTH Term_TermType = 45 // Sequence, NUMBER -> DATUM
	// do NTH or GET_FIELD depending on target object
	Term_BRACKET    Term_TermType = 170 // Sequence | OBJECT, NUMBER | STRING -> DATUM
	Term_INNER_JOIN Term_TermType = 48  // Sequence, Sequence, Function(2) -> Sequence
	Term_OUTER_JOIN Term_TermType = 49  // Sequence, Sequence, Function(2) -> Sequence
	// An inner-join that does an equality comparison on two attributes.
	Term_EQ_JOIN Term_TermType = 50  // Sequence, !STRING, Sequence, {index:!STRING} -> Sequence
	Term_ZIP     Term_TermType = 72  // Sequence -> Sequence
	Term_RANGE   Term_TermType = 173 // -> Sequence                        [0, +inf)
	// Array Ops
	// Insert an element in to an array at a given index.
	Term_INSERT_AT Term_TermType = 82 // ARRAY, NUMBER, DATUM -> ARRAY
	// Remove an element at a given index from an array.
	Term_DELETE_AT Term_TermType = 83 // ARRAY, NUMBER -> ARRAY |
	// ARRAY, NUMBER, NUMBER -> ARRAY
	// Change the element at a given index of an array.
	Term_CHANGE_AT Term_TermType = 84 // ARRAY, NUMBER, DATUM -> ARRAY
	// Splice one array in to another array.
	Term_SPLICE_AT Term_TermType = 85 // ARRAY, NUMBER, ARRAY -> ARRAY
	// * Type Ops
	// Coerces a datum to a named type (e.g. "bool").
	// If you previously used `stream_to_array`, you should use this instead
	// with the type "array".
	Term_COERCE_TO Term_TermType = 51 // Top, STRING -> Top
	// Returns the named type of a datum (e.g. TYPE_OF(true) = "BOOL")
	Term_TYPE_OF Term_TermType = 52 // Top -> STRING
	// * Write Ops (the OBJECTs contain data about number of errors etc.)
	// Updates all the rows in a selection.  Calls its Function with the row
	// to be updated, and then merges the result of that call.
	Term_UPDATE Term_TermType = 53 // StreamSelection, Function(1), {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT |
	// SingleSelection, Function(1), {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT |
	// StreamSelection, OBJECT,      {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT |
	// SingleSelection, OBJECT,      {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT
	// Deletes all the rows in a selection.
	Term_DELETE Term_TermType = 54 // StreamSelection, {durability:STRING, return_changes:BOOL} -> OBJECT | SingleSelection -> OBJECT
	// Replaces all the rows in a selection.  Calls its Function with the row
	// to be replaced, and then discards it and stores the result of that
	// call.
	Term_REPLACE Term_TermType = 55 // StreamSelection, Function(1), {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT | SingleSelection, Function(1), {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT
	// Inserts into a table.  If `conflict` is replace, overwrites
	// entries with the same primary key.  If `conflict` is
	// update, does an update on the entry.  If `conflict` is
	// error, or is omitted, conflicts will trigger an error.
	Term_INSERT Term_TermType = 56 // Table, OBJECT, {conflict:STRING, durability:STRING, return_changes:BOOL} -> OBJECT | Table, Sequence, {conflict:STRING, durability:STRING, return_changes:BOOL} -> OBJECT
	// * Administrative OPs
	// Creates a database with a particular name.
	Term_DB_CREATE Term_TermType = 57 // STRING -> OBJECT
	// Drops a database with a particular name.
	Term_DB_DROP Term_TermType = 58 // STRING -> OBJECT
	// Lists all the databases by name.  (Takes no arguments)
	Term_DB_LIST Term_TermType = 59 // -> ARRAY
	// Creates a table with a particular name in a particular
	// database.  (You may omit the first argument to use the
	// default database.)
	Term_TABLE_CREATE Term_TermType = 60 // Database, STRING, {primary_key:STRING, shards:NUMBER, replicas:NUMBER, primary_replica_tag:STRING} -> OBJECT
	// Database, STRING, {primary_key:STRING, shards:NUMBER, replicas:OBJECT, primary_replica_tag:STRING} -> OBJECT
	// STRING, {primary_key:STRING, shards:NUMBER, replicas:NUMBER, primary_replica_tag:STRING} -> OBJECT
	// STRING, {primary_key:STRING, shards:NUMBER, replicas:OBJECT, primary_replica_tag:STRING} -> OBJECT
	// Drops a table with a particular name from a particular
	// database.  (You may omit the first argument to use the
	// default database.)
	Term_TABLE_DROP Term_TermType = 61 // Database, STRING -> OBJECT
	// STRING -> OBJECT
	// Lists all the tables in a particular database.  (You may
	// omit the first argument to use the default database.)
	Term_TABLE_LIST Term_TermType = 62 // Database -> ARRAY
	//  -> ARRAY
	// Returns the row in the `rethinkdb.table_config` or `rethinkdb.db_config` table
	// that corresponds to the given database or table.
	Term_CONFIG Term_TermType = 174 // Database -> SingleSelection
	// Table -> SingleSelection
	// Returns the row in the `rethinkdb.table_status` table that corresponds to the
	// given table.
	Term_STATUS Term_TermType = 175 // Table -> SingleSelection
	// Called on a table, waits for that table to be ready for read/write operations.
	// Called on a database, waits for all of the tables in the database to be ready.
	// Returns the corresponding row or rows from the `rethinkdb.table_status` table.
	Term_WAIT Term_TermType = 177 // Table -> OBJECT
	// Database -> OBJECT
	// Generates a new config for the given table, or all tables in the given database
	// The `shards` and `replicas` arguments are required. If `emergency_repair` is
	// specified, it will enter a completely different mode of repairing a table
	// which has lost half or more of its replicas.
	Term_RECONFIGURE Term_TermType = 176 // Database|Table, {shards:NUMBER, replicas:NUMBER [,
	//                  dry_run:BOOLEAN]
	//                 } -> OBJECT
	// Database|Table, {shards:NUMBER, replicas:OBJECT [,
	//                  primary_replica_tag:STRING,
	//                  nonvoting_replica_tags:ARRAY,
	//                  dry_run:BOOLEAN]
	//                 } -> OBJECT
	// Table, {emergency_repair:STRING, dry_run:BOOLEAN} -> OBJECT
	// Balances the table's shards but leaves everything else the same. Can also be
	// applied to an entire database at once.
	Term_REBALANCE Term_TermType = 179 // Table -> OBJECT
	// Ensures that previously issued soft-durability writes are complete and
	// written to disk.
	Term_SYNC Term_TermType = 138 // Table -> OBJECT
	// Set global, database, or table-specific permissions
	Term_GRANT Term_TermType = 188 //          -> OBJECT
	// * Secondary indexes OPs
	// Creates a new secondary index with a particular name and definition.
	Term_INDEX_CREATE Term_TermType = 75 // Table, STRING, Function(1), {multi:BOOL} -> OBJECT
	// Drops a secondary index with a particular name from the specified table.
	Term_INDEX_DROP Term_TermType = 76 // Table, STRING -> OBJECT
	// Lists all secondary indexes on a particular table.
	Term_INDEX_LIST Term_TermType = 77 // Table -> ARRAY
	// Gets information about whether or not a set of indexes are ready to
	// be accessed. Returns a list of objects that look like this:
	// {index:STRING, ready:BOOL[, progress:NUMBER]}
	Term_INDEX_STATUS Term_TermType = 139 // Table, STRING... -> ARRAY
	// Blocks until a set of indexes are ready to be accessed. Returns the
	// same values INDEX_STATUS.
	Term_INDEX_WAIT Term_TermType = 140 // Table, STRING... -> ARRAY
	// Renames the given index to a new name
	Term_INDEX_RENAME Term_TermType = 156 // Table, STRING, STRING, {overwrite:BOOL} -> OBJECT
	// * Write hook Function OPs
	// Creates a new write hook function with a particular definition
	Term_SET_WRITE_HOOK Term_TermType = 189 // Table, Function(2)
	// Gets an existing write hook function on a table
	Term_GET_WRITE_HOOK Term_TermType = 190 // Table
	// * Control Operators
	// Calls a function on data
	Term_FUNCALL Term_TermType = 64 // Function(*), DATUM... -> DATUM
	// Executes its first argument, and returns its second argument if it
	// got [true] or its third argument if it got [false] (like an `if`
	// statement).
	Term_BRANCH Term_TermType = 65 // BOOL, Top, Top -> Top
	// Returns true if any of its arguments returns true (short-circuits).
	Term_OR Term_TermType = 66 // BOOL... -> BOOL
	// Returns true if all of its arguments return true (short-circuits).
	Term_AND Term_TermType = 67 // BOOL... -> BOOL
	// Calls its Function with each entry in the sequence
	// and executes the array of terms that Function returns.
	Term_FOR_EACH Term_TermType = 68 // Sequence, Function(1) -> OBJECT
	// An anonymous function.  Takes an array of numbers representing
	// variables (see [VAR] above), and a [Term] to execute with those in
	// scope.  Returns a function that may be passed an array of arguments,
	// then executes the Term with those bound to the variable names.  The
	// user will never construct this directly.  We use it internally for
	// things like `map` which take a function.  The "arity" of a [Function] is
	// the number of arguments it takes.
	// For example, here's what `_X_.map{|x| x+2}` turns into:
	// Term {
	//   type = MAP;
	//   args = [_X_,
	//           Term {
	//             type = Function;
	//             args = [Term {
	//                       type = DATUM;
	//                       datum = Datum {
	//                         type = R_ARRAY;
	//                         r_array = [Datum { type = R_NUM; r_num = 1; }];
	//                       };
	//                     },
	//                     Term {
	//                       type = ADD;
	//                       args = [Term {
	//                                 type = VAR;
	//                                 args = [Term {
	//                                           type = DATUM;
	//                                           datum = Datum { type = R_NUM;
	//                                                           r_num = 1};
	//                                         }];
	//                               },
	//                               Term {
	//                                 type = DATUM;
	//                                 datum = Datum { type = R_NUM; r_num = 2; };
	//                               }];
	//                     }];
	//           }];
	Term_FUNC Term_TermType = 69 // ARRAY, Top -> ARRAY -> Top
	// Indicates to ORDER_BY that this attribute is to be sorted in ascending order.
	Term_ASC Term_TermType = 73 // !STRING -> Ordering
	// Indicates to ORDER_BY that this attribute is to be sorted in descending order.
	Term_DESC Term_TermType = 74 // !STRING -> Ordering
	// Gets info about anything.  INFO is most commonly called on tables.
	Term_INFO Term_TermType = 79 // Top -> OBJECT
	// `a.match(b)` returns a match object if the string `a`
	// matches the regular expression `b`.
	Term_MATCH Term_TermType = 97 // STRING, STRING -> DATUM
	// Change the case of a string.
	Term_UPCASE   Term_TermType = 141 // STRING -> STRING
	Term_DOWNCASE Term_TermType = 142 // STRING -> STRING
	// Select a number of elements from sequence with uniform distribution.
	Term_SAMPLE Term_TermType = 81 // Sequence, NUMBER -> Sequence
	// Evaluates its first argument.  If that argument returns
	// NULL or throws an error related to the absence of an
	// expected value (for instance, accessing a non-existent
	// field or adding NULL to an integer), DEFAULT will either
	// return its second argument or execute it if it's a
	// function.  If the second argument is a function, it will be
	// passed either the text of the error or NULL as its
	// argument.
	Term_DEFAULT Term_TermType = 92 // Top, Top -> Top
	// Parses its first argument as a json string and returns it as a
	// datum.
	Term_JSON Term_TermType = 98 // STRING -> DATUM
	// Parses its first arguments as an ISO 8601 time and returns it as a
	// datum.
	Term_ISO8601 Term_TermType = 99 // STRING -> PSEUDOTYPE(TIME)
	// Prints a time as an ISO 8601 time.
	Term_TO_ISO8601 Term_TermType = 100 // PSEUDOTYPE(TIME) -> STRING
	// Returns a time given seconds since epoch in UTC.
	Term_EPOCH_TIME Term_TermType = 101 // NUMBER -> PSEUDOTYPE(TIME)
	// Returns seconds since epoch in UTC given a time.
	Term_TO_EPOCH_TIME Term_TermType = 102 // PSEUDOTYPE(TIME) -> NUMBER
	// The time the query was received by the server.
	Term_NOW Term_TermType = 103 // -> PSEUDOTYPE(TIME)
	// Puts a time into an ISO 8601 timezone.
	Term_IN_TIMEZONE Term_TermType = 104 // PSEUDOTYPE(TIME), STRING -> PSEUDOTYPE(TIME)
	// a.during(b, c) returns whether a is in the range [b, c)
	Term_DURING Term_TermType = 105 // PSEUDOTYPE(TIME), PSEUDOTYPE(TIME), PSEUDOTYPE(TIME) -> BOOL
	// Retrieves the date portion of a time.
	Term_DATE Term_TermType = 106 // PSEUDOTYPE(TIME) -> PSEUDOTYPE(TIME)
	// x.time_of_day == x.date - x
	Term_TIME_OF_DAY Term_TermType = 126 // PSEUDOTYPE(TIME) -> NUMBER
	// Returns the timezone of a time.
	Term_TIMEZONE Term_TermType = 127 // PSEUDOTYPE(TIME) -> STRING
	// These access the various components of a time.
	Term_YEAR        Term_TermType = 128 // PSEUDOTYPE(TIME) -> NUMBER
	Term_MONTH       Term_TermType = 129 // PSEUDOTYPE(TIME) -> NUMBER
	Term_DAY         Term_TermType = 130 // PSEUDOTYPE(TIME) -> NUMBER
	Term_DAY_OF_WEEK Term_TermType = 131 // PSEUDOTYPE(TIME) -> NUMBER
	Term_DAY_OF_YEAR Term_TermType = 132 // PSEUDOTYPE(TIME) -> NUMBER
	Term_HOURS       Term_TermType = 133 // PSEUDOTYPE(TIME) -> NUMBER
	Term_MINUTES     Term_TermType = 134 // PSEUDOTYPE(TIME) -> NUMBER
	Term_SECONDS     Term_TermType = 135 // PSEUDOTYPE(TIME) -> NUMBER
	// Construct a time from a date and optional timezone or a
	// date+time and optional timezone.
	Term_TIME Term_TermType = 136 // NUMBER, NUMBER, NUMBER, STRING -> PSEUDOTYPE(TIME) |
	// Constants for ISO 8601 days of the week.
	Term_MONDAY    Term_TermType = 107 // -> 1
	Term_TUESDAY   Term_TermType = 108 // -> 2
	Term_WEDNESDAY Term_TermType = 109 // -> 3
	Term_THURSDAY  Term_TermType = 110 // -> 4
	Term_FRIDAY    Term_TermType = 111 // -> 5
	Term_SATURDAY  Term_TermType = 112 // -> 6
	Term_SUNDAY    Term_TermType = 113 // -> 7
	// Constants for ISO 8601 months.
	Term_JANUARY   Term_TermType = 114 // -> 1
	Term_FEBRUARY  Term_TermType = 115 // -> 2
	Term_MARCH     Term_TermType = 116 // -> 3
	Term_APRIL     Term_TermType = 117 // -> 4
	Term_MAY       Term_TermType = 118 // -> 5
	Term_JUNE      Term_TermType = 119 // -> 6
	Term_JULY      Term_TermType = 120 // -> 7
	Term_AUGUST    Term_TermType = 121 // -> 8
	Term_SEPTEMBER Term_TermType = 122 // -> 9
	Term_OCTOBER   Term_TermType = 123 // -> 10
	Term_NOVEMBER  Term_TermType = 124 // -> 11
	Term_DECEMBER  Term_TermType = 125 // -> 12
	// Indicates to MERGE to replace, or remove in case of an empty literal, the
	// other object rather than merge it.
	Term_LITERAL Term_TermType = 137 // -> Merging
	// SEQUENCE, STRING -> GROUPED_SEQUENCE | SEQUENCE, FUNCTION -> GROUPED_SEQUENCE
	Term_GROUP Term_TermType = 144
	Term_SUM   Term_TermType = 145
	Term_AVG   Term_TermType = 146
	Term_MIN   Term_TermType = 147
	Term_MAX   Term_TermType = 148
	// `str.split()` splits on whitespace
	// `str.split(" ")` splits on spaces only
	// `str.split(" ", 5)` splits on spaces with at most 5 results
	// `str.split(nil, 5)` splits on whitespace with at most 5 results
	Term_SPLIT   Term_TermType = 149 // STRING -> ARRAY | STRING, STRING -> ARRAY | STRING, STRING, NUMBER -> ARRAY | STRING, NULL, NUMBER -> ARRAY
	Term_UNGROUP Term_TermType = 150 // GROUPED_DATA -> ARRAY
	// Takes a range of numbers and returns a random number within the range
	Term_RANDOM  Term_TermType = 151 // NUMBER, NUMBER {float:BOOL} -> DATUM
	Term_CHANGES Term_TermType = 152 // TABLE -> STREAM
	Term_ARGS    Term_TermType = 154 // ARRAY -> SPECIAL (used to splice arguments)
	// BINARY is client-only at the moment, it is not supported on the server
	Term_BINARY           Term_TermType = 155 // STRING -> PSEUDOTYPE(BINARY)
	Term_GEOJSON          Term_TermType = 157 // OBJECT -> PSEUDOTYPE(GEOMETRY)
	Term_TO_GEOJSON       Term_TermType = 158 // PSEUDOTYPE(GEOMETRY) -> OBJECT
	Term_POINT            Term_TermType = 159 // NUMBER, NUMBER -> PSEUDOTYPE(GEOMETRY)
	Term_LINE             Term_TermType = 160 // (ARRAY | PSEUDOTYPE(GEOMETRY))... -> PSEUDOTYPE(GEOMETRY)
	Term_POLYGON          Term_TermType = 161 // (ARRAY | PSEUDOTYPE(GEOMETRY))... -> PSEUDOTYPE(GEOMETRY)
	Term_DISTANCE         Term_TermType = 162 // PSEUDOTYPE(GEOMETRY), PSEUDOTYPE(GEOMETRY) {geo_system:STRING, unit:STRING} -> NUMBER
	Term_INTERSECTS       Term_TermType = 163 // PSEUDOTYPE(GEOMETRY), PSEUDOTYPE(GEOMETRY) -> BOOL
	Term_INCLUDES         Term_TermType = 164 // PSEUDOTYPE(GEOMETRY), PSEUDOTYPE(GEOMETRY) -> BOOL
	Term_CIRCLE           Term_TermType = 165 // PSEUDOTYPE(GEOMETRY), NUMBER {num_vertices:NUMBER, geo_system:STRING, unit:STRING, fill:BOOL} -> PSEUDOTYPE(GEOMETRY)
	Term_GET_INTERSECTING Term_TermType = 166 // TABLE, PSEUDOTYPE(GEOMETRY) {index:!STRING} -> StreamSelection
	Term_FILL             Term_TermType = 167 // PSEUDOTYPE(GEOMETRY) -> PSEUDOTYPE(GEOMETRY)
	Term_GET_NEAREST      Term_TermType = 168 // TABLE, PSEUDOTYPE(GEOMETRY) {index:!STRING, max_results:NUM, max_dist:NUM, geo_system:STRING, unit:STRING} -> ARRAY
	Term_POLYGON_SUB      Term_TermType = 171 // PSEUDOTYPE(GEOMETRY), PSEUDOTYPE(GEOMETRY) -> PSEUDOTYPE(GEOMETRY)
	// Returns the datum as a JSON string.
	// N.B.: we would really prefer this be named TO_JSON and that exists as
	// an alias in Python and JavaScript drivers; however it conflicts with the
	// standard `to_json` method defined by Ruby's standard json library.
	Term_TO_JSON_STRING Term_TermType = 172 // DATUM -> STRING
	// Constants for specifying key ranges
	Term_MINVAL Term_TermType = 180
	Term_MAXVAL Term_TermType = 181
	// Bitwise operations
	Term_BIT_AND Term_TermType = 191
	Term_BIT_OR  Term_TermType = 192
	Term_BIT_XOR Term_TermType = 193
	Term_BIT_NOT Term_TermType = 194
	Term_BIT_SAL Term_TermType = 195
	Term_BIT_SAR Term_TermType = 196
)

// Enum value maps for Term_TermType.
var (
	Term_TermType_name = map[int32]string{
		1:   "DATUM",
		2:   "MAKE_ARRAY",
		3:   "MAKE_OBJ",
		10:  "VAR",
		11:  "JAVASCRIPT",
		169: "UUID",
		153: "HTTP",
		12:  "ERROR",
		13:  "IMPLICIT_VAR",
		14:  "DB",
		15:  "TABLE",
		16:  "GET",
		78:  "GET_ALL",
		17:  "EQ",
		18:  "NE",
		19:  "LT",
		20:  "LE",
		21:  "GT",
		22:  "GE",
		23:  "NOT",
		24:  "ADD",
		25:  "SUB",
		26:  "MUL",
		27:  "DIV",
		28:  "MOD",
		183: "FLOOR",
		184: "CEIL",
		185: "ROUND",
		29:  "APPEND",
		80:  "PREPEND",
		95:  "DIFFERENCE",
		88:  "SET_INSERT",
		89:  "SET_INTERSECTION",
		90:  "SET_UNION",
		91:  "SET_DIFFERENCE",
		30:  "SLICE",
		70:  "SKIP",
		71:  "LIMIT",
		87:  "OFFSETS_OF",
		93:  "CONTAINS",
		31:  "GET_FIELD",
		94:  "KEYS",
		186: "VALUES",
		143: "OBJECT",
		32:  "HAS_FIELDS",
		96:  "WITH_FIELDS",
		33:  "PLUCK",
		34:  "WITHOUT",
		35:  "MERGE",
		36:  "BETWEEN_DEPRECATED",
		182: "BETWEEN",
		37:  "REDUCE",
		38:  "MAP",
		187: "FOLD",
		39:  "FILTER",
		40:  "CONCAT_MAP",
		41:  "ORDER_BY",
		42:  "DISTINCT",
		43:  "COUNT",
		86:  "IS_EMPTY",
		44:  "UNION",
		45:  "NTH",
		170: "BRACKET",
		48:  "INNER_JOIN",
		49:  "OUTER_JOIN",
		50:  "EQ_JOIN",
		72:  "ZIP",
		173: "RANGE",
		82:  "INSERT_AT",
		83:  "DELETE_AT",
		84:  "CHANGE_AT",
		85:  "SPLICE_AT",
		51:  "COERCE_TO",
		52:  "TYPE_OF",
		53:  "UPDATE",
		54:  "DELETE",
		55:  "REPLACE",
		56:  "INSERT",
		57:  "DB_CREATE",
		58:  "DB_DROP",
		59:  "DB_LIST",
		60:  "TABLE_CREATE",
		61:  "TABLE_DROP",
		62:  "TABLE_LIST",
		174: "CONFIG",
		175: "STATUS",
		177: "WAIT",
		176: "RECONFIGURE",
		179: "REBALANCE",
		138: "SYNC",
		188: "GRANT",
		75:  "INDEX_CREATE",
		76:  "INDEX_DROP",
		77:  "INDEX_LIST",
		139: "INDEX_STATUS",
		140: "INDEX_WAIT",
		156: "INDEX_RENAME",
		189: "SET_WRITE_HOOK",
		190: "GET_WRITE_HOOK",
		64:  "FUNCALL",
		65:  "BRANCH",
		66:  "OR",
		67:  "AND",
		68:  "FOR_EACH",
		69:  "FUNC",
		73:  "ASC",
		74:  "DESC",
		79:  "INFO",
		97:  "MATCH",
		141: "UPCASE",
		142: "DOWNCASE",
		81:  "SAMPLE",
		92:  "DEFAULT",
		98:  "JSON",
		99:  "ISO8601",
		100: "TO_ISO8601",
		101: "EPOCH_TIME",
		102: "TO_EPOCH_TIME",
		103: "NOW",
		104: "IN_TIMEZONE",
		105: "DURING",
		106: "DATE",
		126: "TIME_OF_DAY",
		127: "TIMEZONE",
		128: "YEAR",
		129: "MONTH",
		130: "DAY",
		131: "DAY_OF_WEEK",
		132: "DAY_OF_YEAR",
		133: "HOURS",
		134: "MINUTES",
		135: "SECONDS",
		136: "TIME",
		107: "MONDAY",
		108: "TUESDAY",
		109: "WEDNESDAY",
		110: "THURSDAY",
		111: "FRIDAY",
		112: "SATURDAY",
		113: "SUNDAY",
		114: "JANUARY",
		115: "FEBRUARY",
		116: "MARCH",
		117: "APRIL",
		118: "MAY",
		119: "JUNE",
		120: "JULY",
		121: "AUGUST",
		122: "SEPTEMBER",
		123: "OCTOBER",
		124: "NOVEMBER",
		125: "DECEMBER",
		137: "LITERAL",
		144: "GROUP",
		145: "SUM",
		146: "AVG",
		147: "MIN",
		148: "MAX",
		149: "SPLIT",
		150: "UNGROUP",
		151: "RANDOM",
		152: "CHANGES",
		154: "ARGS",
		155: "BINARY",
		157: "GEOJSON",
		158: "TO_GEOJSON",
		159: "POINT",
		160: "LINE",
		161: "POLYGON",
		162: "DISTANCE",
		163: "INTERSECTS",
		164: "INCLUDES",
		165: "CIRCLE",
		166: "GET_INTERSECTING",
		167: "FILL",
		168: "GET_NEAREST",
		171: "POLYGON_SUB",
		172: "TO_JSON_STRING",
		180: "MINVAL",
		181: "MAXVAL",
		191: "BIT_AND",
		192: "BIT_OR",
		193: "BIT_XOR",
		194: "BIT_NOT",
		195: "BIT_SAL",
		196: "BIT_SAR",
	}
	Term_TermType_value = map[string]int32{
		"DATUM":              1,
		"MAKE_ARRAY":         2,
		"MAKE_OBJ":           3,
		"VAR":                10,
		"JAVASCRIPT":         11,
		"UUID":               169,
		"HTTP":               153,
		"ERROR":              12,
		"IMPLICIT_VAR":       13,
		"DB":                 14,
		"TABLE":              15,
		"GET":                16,
		"GET_ALL":            78,
		"EQ":                 17,
		"NE":                 18,
		"LT":                 19,
		"LE":                 20,
		"GT":                 21,
		"GE":                 22,
		"NOT":                23,
		"ADD":                24,
		"SUB":                25,
		"MUL":                26,
		"DIV":                27,
		"MOD":                28,
		"FLOOR":              183,
		"CEIL":               184,
		"ROUND":              185,
		"APPEND":             29,
		"PREPEND":            80,
		"DIFFERENCE":         95,
		"SET_INSERT":         88,
		"SET_INTERSECTION":   89,
		"SET_UNION":          90,
		"SET_DIFFERENCE":     91,
		"SLICE":              30,
		"SKIP":               70,
		"LIMIT":              71,
		"OFFSETS_OF":         87,
		"CONTAINS":           93,
		"GET_FIELD":          31,
		"KEYS":               94,
		"VALUES":             186,
		"OBJECT":             143,
		"HAS_FIELDS":         32,
		"WITH_FIELDS":        96,
		"PLUCK":              33,
		"WITHOUT":            34,
		"MERGE":              35,
		"BETWEEN_DEPRECATED": 36,
		"BETWEEN":            182,
		"REDUCE":             37,
		"MAP":                38,
		"FOLD":               187,
		"FILTER":             39,
		"CONCAT_MAP":         40,
		"ORDER_BY":           41,
		"DISTINCT":           42,
		"COUNT":              43,
		"IS_EMPTY":           86,
		"UNION":              44,
		"NTH":                45,
		"BRACKET":            170,
		"INNER_JOIN":         48,
		"OUTER_JOIN":         49,
		"EQ_JOIN":            50,
		"ZIP":                72,
		"RANGE":              173,
		"INSERT_AT":          82,
		"DELETE_AT":          83,
		"CHANGE_AT":          84,
		"SPLICE_AT":          85,
		"COERCE_TO":          51,
		"TYPE_OF":            52,
		"UPDATE":             53,
		"DELETE":             54,
		"REPLACE":            55,
		"INSERT":             56,
		"DB_CREATE":          57,
		"DB_DROP":            58,
		"DB_LIST":            59,
		"TABLE_CREATE":       60,
		"TABLE_DROP":         61,
		"TABLE_LIST":         62,
		"CONFIG":             174,
		"STATUS":             175,
		"WAIT":               177,
		"RECONFIGURE":        176,
		"REBALANCE":          179,
		"SYNC":               138,
		"GRANT":              188,
		"INDEX_CREATE":       75,
		"INDEX_DROP":         76,
		"INDEX_LIST":         77,
		"INDEX_STATUS":       139,
		"INDEX_WAIT":         140,
		"INDEX_RENAME":       156,
		"SET_WRITE_HOOK":     189,
		"GET_WRITE_HOOK":     190,
		"FUNCALL":            64,
		"BRANCH":             65,
		"OR":                 66,
		"AND":                67,
		"FOR_EACH":           68,
		"FUNC":               69,
		"ASC":                73,
		"DESC":               74,
		"INFO":               79,
		"MATCH":              97,
		"UPCASE":             141,
		"DOWNCASE":           142,
		"SAMPLE":             81,
		"DEFAULT":            92,
		"JSON":               98,
		"ISO8601":            99,
		"TO_ISO8601":         100,
		"EPOCH_TIME":         101,
		"TO_EPOCH_TIME":      102,
		"NOW":                103,
		"IN_TIMEZONE":        104,
		"DURING":             105,
		"DATE":               106,
		"TIME_OF_DAY":        126,
		"TIMEZONE":           127,
		"YEAR":               128,
		"MONTH":              129,
		"DAY":                130,
		"DAY_OF_WEEK":        131,
		"DAY_OF_YEAR":        132,
		"HOURS":              133,
		"MINUTES":            134,
		"SECONDS":            135,
		"TIME":               136,
		"MONDAY":             107,
		"TUESDAY":            108,
		"WEDNESDAY":          109,
		"THURSDAY":           110,
		"FRIDAY":             111,
		"SATURDAY":           112,
		"SUNDAY":             113,
		"JANUARY":            114,
		"FEBRUARY":           115,
		"MARCH":              116,
		"APRIL":              117,
		"MAY":                118,
		"JUNE":               119,
		"JULY":               120,
		"AUGUST":             121,
		"SEPTEMBER":          122,
		"OCTOBER":            123,
		"NOVEMBER":           124,
		"DECEMBER":           125,
		"LITERAL":            137,
		"GROUP":              144,
		"SUM":                145,
		"AVG":                146,
		"MIN":                147,
		"MAX":                148,
		"SPLIT":              149,
		"UNGROUP":            150,
		"RANDOM":             151,
		"CHANGES":            152,
		"ARGS":               154,
		"BINARY":             155,
		"GEOJSON":            157,
		"TO_GEOJSON":         158,
		"POINT":              159,
		"LINE":               160,
		"POLYGON":            161,
		"DISTANCE":           162,
		"INTERSECTS":         163,
		"INCLUDES":           164,
		"CIRCLE":             165,
		"GET_INTERSECTING":   166,
		"FILL":               167,
		"GET_NEAREST":        168,
		"POLYGON_SUB":        171,
		"TO_JSON_STRING":     172,
		"MINVAL":             180,
		"MAXVAL":             181,
		"BIT_AND":            191,
		"BIT_OR":             192,
		"BIT_XOR":            193,
		"BIT_NOT":            194,
		"BIT_SAL":            195,
		"BIT_SAR":            196,
	}
)

func (x Term_TermType) Enum() *Term_TermType {
	p := new(Term_TermType)
	*p = x
	return p
}

func (x Term_TermType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Term_TermType) Descriptor() protoreflect.EnumDescriptor {
	return file_ql2_proto_enumTypes[8].Descriptor()
}

func (Term_TermType) Type() protoreflect.EnumType {
	return &file_ql2_proto_enumTypes[8]
}

func (x Term_TermType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Term_TermType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Term_TermType(num)
	return nil
}

// Deprecated: Use Term_TermType.Descriptor instead.
func (Term_TermType) EnumDescriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{6, 0}
}

type VersionDummy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *VersionDummy) Reset() {
	*x = VersionDummy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ql2_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VersionDummy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersionDummy) ProtoMessage() {}

func (x *VersionDummy) ProtoReflect() protoreflect.Message {
	mi := &file_ql2_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersionDummy.ProtoReflect.Descriptor instead.
func (*VersionDummy) Descriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{0}
}

// You send one of:
// * A [START] query with a [Term] to evaluate and a unique-per-connection token.
// * A [CONTINUE] query with the same token as a [START] query that returned
//   [SUCCESS_PARTIAL] in its [Response].
// * A [STOP] query with the same token as a [START] query that you want to stop.
// * A [NOREPLY_WAIT] query with a unique per-connection token. The server answers
//   with a [WAIT_COMPLETE] [Response].
// * A [SERVER_INFO] query. The server answers with a [SERVER_INFO] [Response].
type Query struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Type *Query_QueryType `protobuf:"varint,1,opt,name=type,enum=Query_QueryType" json:"type,omitempty"`
	// A [Term] is how we represent the operations we want a query to perform.
	Query *Term  `protobuf:"bytes,2,opt,name=query" json:"query,omitempty"` // only present when [type] = [START]
	Token *int64 `protobuf:"varint,3,opt,name=token" json:"token,omitempty"`
	// This flag is ignored on the server.  `noreply` should be added
	// to `global_optargs` instead (the key "noreply" should map to
	// either true or false).
	OBSOLETENoreply *bool `protobuf:"varint,4,opt,name=OBSOLETE_noreply,json=OBSOLETENoreply,def=0" json:"OBSOLETE_noreply,omitempty"`
	// If this is set to [true], then [Datum] values will sometimes be
	// of [DatumType] [R_JSON] (see below).  This can provide enormous
	// speedups in languages with poor protobuf libraries.
	AcceptsRJson  *bool              `protobuf:"varint,5,opt,name=accepts_r_json,json=acceptsRJson,def=0" json:"accepts_r_json,omitempty"`
	GlobalOptargs []*Query_AssocPair `protobuf:"bytes,6,rep,name=global_optargs,json=globalOptargs" json:"global_optargs,omitempty"`
}

// Default values for Query fields.
const (
	Default_Query_OBSOLETENoreply = bool(false)
	Default_Query_AcceptsRJson    = bool(false)
)

func (x *Query) Reset() {
	*x = Query{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ql2_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Query) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Query) ProtoMessage() {}

func (x *Query) ProtoReflect() protoreflect.Message {
	mi := &file_ql2_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Query.ProtoReflect.Descriptor instead.
func (*Query) Descriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{1}
}

func (x *Query) GetType() Query_QueryType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return Query_START
}

func (x *Query) GetQuery() *Term {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *Query) GetToken() int64 {
	if x != nil && x.Token != nil {
		return *x.Token
	}
	return 0
}

func (x *Query) GetOBSOLETENoreply() bool {
	if x != nil && x.OBSOLETENoreply != nil {
		return *x.OBSOLETENoreply
	}
	return Default_Query_OBSOLETENoreply
}

func (x *Query) GetAcceptsRJson() bool {
	if x != nil && x.AcceptsRJson != nil {
		return *x.AcceptsRJson
	}
	return Default_Query_AcceptsRJson
}

func (x *Query) GetGlobalOptargs() []*Query_AssocPair {
	if x != nil {
		return x.GlobalOptargs
	}
	return nil
}

// A backtrace frame (see `backtrace` in Response below)
type Frame struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Type *Frame_FrameType `protobuf:"varint,1,opt,name=type,enum=Frame_FrameType" json:"type,omitempty"`
	Pos  *int64           `protobuf:"varint,2,opt,name=pos" json:"pos,omitempty"` // The index of the positional argument.
	Opt  *string          `protobuf:"bytes,3,opt,name=opt" json:"opt,omitempty"`  // The name of the optional argument.
}

func (x *Frame) Reset() {
	*x = Frame{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ql2_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Frame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Frame) ProtoMessage() {}

func (x *Frame) ProtoReflect() protoreflect.Message {
	mi := &file_ql2_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Frame.ProtoReflect.Descriptor instead.
func (*Frame) Descriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{2}
}

func (x *Frame) GetType() Frame_FrameType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return Frame_POS
}

func (x *Frame) GetPos() int64 {
	if x != nil && x.Pos != nil {
		return *x.Pos
	}
	return 0
}

func (x *Frame) GetOpt() string {
	if x != nil && x.Opt != nil {
		return *x.Opt
	}
	return ""
}

type Backtrace struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Frames []*Frame `protobuf:"bytes,1,rep,name=frames" json:"frames,omitempty"`
}

func (x *Backtrace) Reset() {
	*x = Backtrace{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ql2_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Backtrace) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backtrace) ProtoMessage() {}

func (x *Backtrace) ProtoReflect() protoreflect.Message {
	mi := &file_ql2_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backtrace.ProtoReflect.Descriptor instead.
func (*Backtrace) Descriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{3}
}

func (x *Backtrace) GetFrames() []*Frame {
	if x != nil {
		return x.Frames
	}
	return nil
}

// You get back a response with the same [token] as your query.
type Response struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Type      *Response_ResponseType  `protobuf:"varint,1,opt,name=type,enum=Response_ResponseType" json:"type,omitempty"`
	ErrorType *Response_ErrorType     `protobuf:"varint,7,opt,name=error_type,json=errorType,enum=Response_ErrorType" json:"error_type,omitempty"`
	Notes     []Response_ResponseNote `protobuf:"varint,6,rep,name=notes,enum=Response_ResponseNote" json:"notes,omitempty"`
	Token     *int64                  `protobuf:"varint,2,opt,name=token" json:"token,omitempty"` // Indicates what [Query] this response corresponds to.
	// [response] contains 1 RQL datum if [type] is [SUCCESS_ATOM] or
	// [SERVER_INFO].  [response] contains many RQL data if [type] is
	// [SUCCESS_SEQUENCE] or [SUCCESS_PARTIAL].  [response] contains 1
	// error message (of type [R_STR]) in all other cases.
	Response []*Datum `protobuf:"bytes,3,rep,name=response" json:"response,omitempty"`
	// If [type] is [CLIENT_ERROR], [TYPE_ERROR], or [RUNTIME_ERROR], then a
	// backtrace will be provided.  The backtrace says where in the query the
	// error occurred.  Ideally this information will be presented to the user as
	// a pretty-printed version of their query with the erroneous section
	// underlined.  A backtrace is a series of 0 or more [Frame]s, each of which
	// specifies either the index of a positional argument or the name of an
	// optional argument.  (Those words will make more sense if you look at the
	// [Term] message below.)
	Backtrace *Backtrace `protobuf:"bytes,4,opt,name=backtrace" json:"backtrace,omitempty"` // Contains n [Frame]s when you get back an error.
	// If the [global_optargs] in the [Query] that this [Response] is a
	// response to contains a key "profile" which maps to a static value of
	// true then [profile] will contain a [Datum] which provides profiling
	// information about the execution of the query. This field should be
	// returned to the user along with the result that would normally be
	// returned (a datum or a cursor). In official drivers this is accomplished
	// by putting them inside of an object with "value" mapping to the return
	// value and "profile" mapping to the profile object.
	Profile *Datum `protobuf:"bytes,5,opt,name=profile" json:"profile,omitempty"`
}

func (x *Response) Reset() {
	*x = Response{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ql2_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Response) ProtoMessage() {}

func (x *Response) ProtoReflect() protoreflect.Message {
	mi := &file_ql2_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Response.ProtoReflect.Descriptor instead.
func (*Response) Descriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{4}
}

func (x *Response) GetType() Response_ResponseType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return Response_SUCCESS_ATOM
}

func (x *Response) GetErrorType() Response_ErrorType {
	if x != nil && x.ErrorType != nil {
		return *x.ErrorType
	}
	return Response_INTERNAL
}

func (x *Response) GetNotes() []Response_ResponseNote {
	if x != nil {
		return x.Notes
	}
	return nil
}

func (x *Response) GetToken() int64 {
	if x != nil && x.Token != nil {
		return *x.Token
	}
	return 0
}

func (x *Response) GetResponse() []*Datum {
	if x != nil {
		return x.Response
	}
	return nil
}

func (x *Response) GetBacktrace() *Backtrace {
	if x != nil {
		return x.Backtrace
	}
	return nil
}

func (x *Response) GetProfile() *Datum {
	if x != nil {
		return x.Profile
	}
	return nil
}

// A [Datum] is a chunk of data that can be serialized to disk or returned to
// the user in a Response.  Currently we only support JSON types, but we may
// support other types in the future (e.g., a date type or an integer type).
type Datum struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Type    *Datum_DatumType   `protobuf:"varint,1,opt,name=type,enum=Datum_DatumType" json:"type,omitempty"`
	RBool   *bool              `protobuf:"varint,2,opt,name=r_bool,json=rBool" json:"r_bool,omitempty"`
	RNum    *float64           `protobuf:"fixed64,3,opt,name=r_num,json=rNum" json:"r_num,omitempty"`
	RStr    *string            `protobuf:"bytes,4,opt,name=r_str,json=rStr" json:"r_str,omitempty"`
	RArray  []*Datum           `protobuf:"bytes,5,rep,name=r_array,json=rArray" json:"r_array,omitempty"`
	RObject []*Datum_AssocPair `protobuf:"bytes,6,rep,name=r_object,json=rObject" json:"r_object,omitempty"`
}

func (x *Datum) Reset() {
	*x = Datum{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ql2_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Datum) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Datum) ProtoMessage() {}

func (x *Datum) ProtoReflect() protoreflect.Message {
	mi := &file_ql2_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Datum.ProtoReflect.Descriptor instead.
func (*Datum) Descriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{5}
}

func (x *Datum) GetType() Datum_DatumType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return Datum_R_NULL
}

func (x *Datum) GetRBool() bool {
	if x != nil && x.RBool != nil {
		return *x.RBool
	}
	return false
}

func (x *Datum) GetRNum() float64 {
	if x != nil && x.RNum != nil {
		return *x.RNum
	}
	return 0
}

func (x *Datum) GetRStr() string {
	if x != nil && x.RStr != nil {
		return *x.RStr
	}
	return ""
}

func (x *Datum) GetRArray() []*Datum {
	if x != nil {
		return x.RArray
	}
	return nil
}

func (x *Datum) GetRObject() []*Datum_AssocPair {
	if x != nil {
		return x.RObject
	}
	return nil
}

// A [Term] is either a piece of data (see **Datum** above), or an operator and
// its operands.  If you have a [Datum], it's stored in the member [datum].  If
// you have an operator, its positional arguments are stored in [args] and its
// optional arguments are stored in [optargs].
//
// A note about type signatures:
// We use the following notation to denote types:
//   arg1_type, arg2_type, argrest_type... -> result_type
// So, for example, if we have a function `avg` that takes any number of
// arguments and averages them, we might write:
//   NUMBER... -> NUMBER
// Or if we had a function that took one number modulo another:
//   NUMBER, NUMBER -> NUMBER
// Or a function that takes a table and a primary key of any Datum type, then
// retrieves the entry with that primary key:
//   Table, DATUM -> OBJECT
// Some arguments must be provided as literal values (and not the results of sub
// terms).  These are marked with a `!`.
// Optional arguments are specified within curly braces as argname `:` value
// type (e.x `{noreply:BOOL}`)
// Many RQL operations are polymorphic. For these, alternative type signatures
// are separated by `|`.
//
// The RQL type hierarchy is as follows:
//   Top
//     DATUM
//       NULL
//       BOOL
//       NUMBER
//       STRING
//       OBJECT
//         SingleSelection
//       ARRAY
//     Sequence
//       ARRAY
//       Stream
//         StreamSelection
//           Table
//     Database
//     Function
//     Ordering - used only by ORDER_BY
//     Pathspec -- an object, string, or array that specifies a path
//   Error
type Term struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Type *Term_TermType `protobuf:"varint,1,opt,name=type,enum=Term_TermType" json:"type,omitempty"`
	// This is only used when type is DATUM.
	Datum   *Datum            `protobuf:"bytes,2,opt,name=datum" json:"datum,omitempty"`
	Args    []*Term           `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`       // Holds the positional arguments of the query.
	Optargs []*Term_AssocPair `protobuf:"bytes,4,rep,name=optargs" json:"optargs,omitempty"` // Holds the optional arguments of the query.
}

func (x *Term) Reset() {
	*x = Term{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ql2_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Term) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Term) ProtoMessage() {}

func (x *Term) ProtoReflect() protoreflect.Message {
	mi := &file_ql2_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Term.ProtoReflect.Descriptor instead.
func (*Term) Descriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{6}
}

func (x *Term) GetType() Term_TermType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return Term_DATUM
}

func (x *Term) GetDatum() *Datum {
	if x != nil {
		return x.Datum
	}
	return nil
}

func (x *Term) GetArgs() []*Term {
	if x != nil {
		return x.Args
	}
	return nil
}

func (x *Term) GetOptargs() []*Term_AssocPair {
	if x != nil {
		return x.Optargs
	}
	return nil
}

type Query_AssocPair struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Val *Term   `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
}

func (x *Query_AssocPair) Reset() {
	*x = Query_AssocPair{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ql2_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Query_AssocPair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Query_AssocPair) ProtoMessage() {}

func (x *Query_AssocPair) ProtoReflect() protoreflect.Message {
	mi := &file_ql2_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Query_AssocPair.ProtoReflect.Descriptor instead.
func (*Query_AssocPair) Descriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{1, 0}
}

func (x *Query_AssocPair) GetKey() string {
	if x != nil && x.Key != nil {
		return *x.Key
	}
	return ""
}

func (x *Query_AssocPair) GetVal() *Term {
	if x != nil {
		return x.Val
	}
	return nil
}

type Datum_AssocPair struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Val *Datum  `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
}

func (x *Datum_AssocPair) Reset() {
	*x = Datum_AssocPair{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ql2_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Datum_AssocPair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Datum_AssocPair) ProtoMessage() {}

func (x *Datum_AssocPair) ProtoReflect() protoreflect.Message {
	mi := &file_ql2_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Datum_AssocPair.ProtoReflect.Descriptor instead.
func (*Datum_AssocPair) Descriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{5, 0}
}

func (x *Datum_AssocPair) GetKey() string {
	if x != nil && x.Key != nil {
		return *x.Key
	}
	return ""
}

func (x *Datum_AssocPair) GetVal() *Datum {
	if x != nil {
		return x.Val
	}
	return nil
}

type Term_AssocPair struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Val *Term   `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
}

func (x *Term_AssocPair) Reset() {
	*x = Term_AssocPair{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ql2_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Term_AssocPair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Term_AssocPair) ProtoMessage() {}

func (x *Term_AssocPair) ProtoReflect() protoreflect.Message {
	mi := &file_ql2_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Term_AssocPair.ProtoReflect.Descriptor instead.
func (*Term_AssocPair) Descriptor() ([]byte, []int) {
	return file_ql2_proto_rawDescGZIP(), []int{6, 0}
}

func (x *Term_AssocPair) GetKey() string {
	if x != nil && x.Key != nil {
		return *x.Key
	}
	return ""
}

func (x *Term_AssocPair) GetVal() *Term {
	if x != nil {
		return x.Val
	}
	return nil
}

var File_ql2_proto protoreflect.FileDescriptor

var file_ql2_proto_rawDesc = []byte{
	0x0a, 0x09, 0x71, 0x6c, 0x32, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x8b, 0x01, 0x0a, 0x0c,
	0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x44, 0x75, 0x6d, 0x6d, 0x79, 0x22, 0x4f, 0x0a, 0x07,
	0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x0c, 0x0a, 0x04, 0x56, 0x30, 0x5f, 0x31, 0x10,
	0xb6, 0xf4, 0x86, 0xfb, 0x03, 0x12, 0x0c, 0x0a, 0x04, 0x56, 0x30, 0x5f, 0x32, 0x10, 0xe1, 0x83,
	0xc2, 0x91, 0x07, 0x12, 0x0c, 0x0a, 0x04, 0x56, 0x30, 0x5f, 0x33, 0x10, 0xbe, 0xd0, 0xd7, 0xfb,
	0x05, 0x12, 0x0c, 0x0a, 0x04, 0x56, 0x30, 0x5f, 0x34, 0x10, 0xa0, 0xda, 0xb0, 0x80, 0x04, 0x12,
	0x0c, 0x0a, 0x04, 0x56, 0x31, 0x5f, 0x30, 0x10, 0xc3, 0xfb, 0x8a, 0xa6, 0x03, 0x22, 0x2a, 0x0a,
	0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x10, 0x0a, 0x08, 0x50, 0x52, 0x4f,
	0x54, 0x4f, 0x42, 0x55, 0x46, 0x10, 0xc1, 0xf8, 0xff, 0xb8, 0x02, 0x12, 0x0c, 0x0a, 0x04, 0x4a,
	0x53, 0x4f, 0x4e, 0x10, 0xc7, 0xe1, 0xa5, 0xf3, 0x07, 0x22, 0x83, 0x03, 0x0a, 0x05, 0x51, 0x75,
	0x65, 0x72, 0x79, 0x12, 0x24, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x10, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x54,
	0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x1b, 0x0a, 0x05, 0x71, 0x75, 0x65,
	0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x05, 0x2e, 0x54, 0x65, 0x72, 0x6d, 0x52,
	0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x30, 0x0a, 0x10,
	0x4f, 0x42, 0x53, 0x4f, 0x4c, 0x45, 0x54, 0x45, 0x5f, 0x6e, 0x6f, 0x72, 0x65, 0x70, 0x6c, 0x79,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x52, 0x0f, 0x4f,
	0x42, 0x53, 0x4f, 0x4c, 0x45, 0x54, 0x45, 0x4e, 0x6f, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x2b,
	0x0a, 0x0e, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x73, 0x5f, 0x72, 0x5f, 0x6a, 0x73, 0x6f, 0x6e,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x52, 0x0c, 0x61,
	0x63, 0x63, 0x65, 0x70, 0x74, 0x73, 0x52, 0x4a, 0x73, 0x6f, 0x6e, 0x12, 0x37, 0x0a, 0x0e, 0x67,
	0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x5f, 0x6f, 0x70, 0x74, 0x61, 0x72, 0x67, 0x73, 0x18, 0x06, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x2e, 0x41, 0x73, 0x73, 0x6f,
	0x63, 0x50, 0x61, 0x69, 0x72, 0x52, 0x0d, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x4f, 0x70, 0x74,
	0x61, 0x72, 0x67, 0x73, 0x1a, 0x36, 0x0a, 0x09, 0x41, 0x73, 0x73, 0x6f, 0x63, 0x50, 0x61, 0x69,
	0x72, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
	0x6b, 0x65, 0x79, 0x12, 0x17, 0x0a, 0x03, 0x76, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x05, 0x2e, 0x54, 0x65, 0x72, 0x6d, 0x52, 0x03, 0x76, 0x61, 0x6c, 0x22, 0x51, 0x0a, 0x09,
	0x51, 0x75, 0x65, 0x72, 0x79, 0x54, 0x79, 0x70, 0x65, 0x12, 0x09, 0x0a, 0x05, 0x53, 0x54, 0x41,
	0x52, 0x54, 0x10, 0x01, 0x12, 0x0c, 0x0a, 0x08, 0x43, 0x4f, 0x4e, 0x54, 0x49, 0x4e, 0x55, 0x45,
	0x10, 0x02, 0x12, 0x08, 0x0a, 0x04, 0x53, 0x54, 0x4f, 0x50, 0x10, 0x03, 0x12, 0x10, 0x0a, 0x0c,
	0x4e, 0x4f, 0x52, 0x45, 0x50, 0x4c, 0x59, 0x5f, 0x57, 0x41, 0x49, 0x54, 0x10, 0x04, 0x12, 0x0f,
	0x0a, 0x0b, 0x53, 0x45, 0x52, 0x56, 0x45, 0x52, 0x5f, 0x49, 0x4e, 0x46, 0x4f, 0x10, 0x05, 0x22,
	0x70, 0x0a, 0x05, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x12, 0x24, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x2e, 0x46,
	0x72, 0x61, 0x6d, 0x65, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x10,
	0x0a, 0x03, 0x70, 0x6f, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x70, 0x6f, 0x73,
	0x12, 0x10, 0x0a, 0x03, 0x6f, 0x70, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6f,
	0x70, 0x74, 0x22, 0x1d, 0x0a, 0x09, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12,
	0x07, 0x0a, 0x03, 0x50, 0x4f, 0x53, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x4f, 0x50, 0x54, 0x10,
	0x02, 0x22, 0x2b, 0x0a, 0x09, 0x42, 0x61, 0x63, 0x6b, 0x74, 0x72, 0x61, 0x63, 0x65, 0x12, 0x1e,
	0x0a, 0x06, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x06,
	0x2e, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x52, 0x06, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x73, 0x22, 0xe9,
	0x05, 0x0a, 0x08, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2a, 0x0a, 0x04, 0x74,
	0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x54, 0x79, 0x70,
	0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x32, 0x0a, 0x0a, 0x65, 0x72, 0x72, 0x6f, 0x72,
	0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x13, 0x2e, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65,
	0x52, 0x09, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65, 0x12, 0x2c, 0x0a, 0x05, 0x6e,
	0x6f, 0x74, 0x65, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x4e, 0x6f,
	0x74, 0x65, 0x52, 0x05, 0x6e, 0x6f, 0x74, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b,
	0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x12,
	0x22, 0x0a, 0x08, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x18, 0x03, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x06, 0x2e, 0x44, 0x61, 0x74, 0x75, 0x6d, 0x52, 0x08, 0x72, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x09, 0x62, 0x61, 0x63, 0x6b, 0x74, 0x72, 0x61, 0x63, 0x65,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x74, 0x72, 0x61,
	0x63, 0x65, 0x52, 0x09, 0x62, 0x61, 0x63, 0x6b, 0x74, 0x72, 0x61, 0x63, 0x65, 0x12, 0x20, 0x0a,
	0x07, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x06,
	0x2e, 0x44, 0x61, 0x74, 0x75, 0x6d, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x22,
	0xa7, 0x01, 0x0a, 0x0c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x54, 0x79, 0x70, 0x65,
	0x12, 0x10, 0x0a, 0x0c, 0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x5f, 0x41, 0x54, 0x4f, 0x4d,
	0x10, 0x01, 0x12, 0x14, 0x0a, 0x10, 0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x5f, 0x53, 0x45,
	0x51, 0x55, 0x45, 0x4e, 0x43, 0x45, 0x10, 0x02, 0x12, 0x13, 0x0a, 0x0f, 0x53, 0x55, 0x43, 0x43,
	0x45, 0x53, 0x53, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x41, 0x4c, 0x10, 0x03, 0x12, 0x11, 0x0a,
	0x0d, 0x57, 0x41, 0x49, 0x54, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x4c, 0x45, 0x54, 0x45, 0x10, 0x04,
	0x12, 0x0f, 0x0a, 0x0b, 0x53, 0x45, 0x52, 0x56, 0x45, 0x52, 0x5f, 0x49, 0x4e, 0x46, 0x4f, 0x10,
	0x05, 0x12, 0x10, 0x0a, 0x0c, 0x43, 0x4c, 0x49, 0x45, 0x4e, 0x54, 0x5f, 0x45, 0x52, 0x52, 0x4f,
	0x52, 0x10, 0x10, 0x12, 0x11, 0x0a, 0x0d, 0x43, 0x4f, 0x4d, 0x50, 0x49, 0x4c, 0x45, 0x5f, 0x45,
	0x52, 0x52, 0x4f, 0x52, 0x10, 0x11, 0x12, 0x11, 0x0a, 0x0d, 0x52, 0x55, 0x4e, 0x54, 0x49, 0x4d,
	0x45, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x12, 0x22, 0xac, 0x01, 0x0a, 0x09, 0x45, 0x72,
	0x72, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0e, 0x0a, 0x08, 0x49, 0x4e, 0x54, 0x45, 0x52,
	0x4e, 0x41, 0x4c, 0x10, 0xc0, 0x84, 0x3d, 0x12, 0x14, 0x0a, 0x0e, 0x52, 0x45, 0x53, 0x4f, 0x55,
	0x52, 0x43, 0x45, 0x5f, 0x4c, 0x49, 0x4d, 0x49, 0x54, 0x10, 0x80, 0x89, 0x7a, 0x12, 0x12, 0x0a,
	0x0b, 0x51, 0x55, 0x45, 0x52, 0x59, 0x5f, 0x4c, 0x4f, 0x47, 0x49, 0x43, 0x10, 0xc0, 0x8d, 0xb7,
	0x01, 0x12, 0x14, 0x0a, 0x0d, 0x4e, 0x4f, 0x4e, 0x5f, 0x45, 0x58, 0x49, 0x53, 0x54, 0x45, 0x4e,
	0x43, 0x45, 0x10, 0xe0, 0x9a, 0xbd, 0x01, 0x12, 0x10, 0x0a, 0x09, 0x4f, 0x50, 0x5f, 0x46, 0x41,
	0x49, 0x4c, 0x45, 0x44, 0x10, 0xa0, 0x9f, 0xfa, 0x01, 0x12, 0x17, 0x0a, 0x10, 0x4f, 0x50, 0x5f,
	0x49, 0x4e, 0x44, 0x45, 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x54, 0x45, 0x10, 0xc0, 0xac,
	0x80, 0x02, 0x12, 0x0b, 0x0a, 0x04, 0x55, 0x53, 0x45, 0x52, 0x10, 0xc0, 0x96, 0xb1, 0x02, 0x12,
	0x17, 0x0a, 0x10, 0x50, 0x45, 0x52, 0x4d, 0x49, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x45, 0x52,
	0x52, 0x4f, 0x52, 0x10, 0x80, 0x9b, 0xee, 0x02, 0x22, 0x70, 0x0a, 0x0c, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x4e, 0x6f, 0x74, 0x65, 0x12, 0x11, 0x0a, 0x0d, 0x53, 0x45, 0x51, 0x55,
	0x45, 0x4e, 0x43, 0x45, 0x5f, 0x46, 0x45, 0x45, 0x44, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x41,
	0x54, 0x4f, 0x4d, 0x5f, 0x46, 0x45, 0x45, 0x44, 0x10, 0x02, 0x12, 0x17, 0x0a, 0x13, 0x4f, 0x52,
	0x44, 0x45, 0x52, 0x5f, 0x42, 0x59, 0x5f, 0x4c, 0x49, 0x4d, 0x49, 0x54, 0x5f, 0x46, 0x45, 0x45,
	0x44, 0x10, 0x03, 0x12, 0x10, 0x0a, 0x0c, 0x55, 0x4e, 0x49, 0x4f, 0x4e, 0x45, 0x44, 0x5f, 0x46,
	0x45, 0x45, 0x44, 0x10, 0x04, 0x12, 0x13, 0x0a, 0x0f, 0x49, 0x4e, 0x43, 0x4c, 0x55, 0x44, 0x45,
	0x53, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45, 0x53, 0x10, 0x05, 0x22, 0xd7, 0x02, 0x0a, 0x05, 0x44,
	0x61, 0x74, 0x75, 0x6d, 0x12, 0x24, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x10, 0x2e, 0x44, 0x61, 0x74, 0x75, 0x6d, 0x2e, 0x44, 0x61, 0x74, 0x75, 0x6d,
	0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x15, 0x0a, 0x06, 0x72, 0x5f,
	0x62, 0x6f, 0x6f, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x72, 0x42, 0x6f, 0x6f,
	0x6c, 0x12, 0x13, 0x0a, 0x05, 0x72, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01,
	0x52, 0x04, 0x72, 0x4e, 0x75, 0x6d, 0x12, 0x13, 0x0a, 0x05, 0x72, 0x5f, 0x73, 0x74, 0x72, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x72, 0x53, 0x74, 0x72, 0x12, 0x1f, 0x0a, 0x07, 0x72,
	0x5f, 0x61, 0x72, 0x72, 0x61, 0x79, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x06, 0x2e, 0x44,
	0x61, 0x74, 0x75, 0x6d, 0x52, 0x06, 0x72, 0x41, 0x72, 0x72, 0x61, 0x79, 0x12, 0x2b, 0x0a, 0x08,
	0x72, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10,
	0x2e, 0x44, 0x61, 0x74, 0x75, 0x6d, 0x2e, 0x41, 0x73, 0x73, 0x6f, 0x63, 0x50, 0x61, 0x69, 0x72,
	0x52, 0x07, 0x72, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x1a, 0x37, 0x0a, 0x09, 0x41, 0x73, 0x73,
	0x6f, 0x63, 0x50, 0x61, 0x69, 0x72, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x18, 0x0a, 0x03, 0x76, 0x61, 0x6c, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x06, 0x2e, 0x44, 0x61, 0x74, 0x75, 0x6d, 0x52, 0x03, 0x76,
	0x61, 0x6c, 0x22, 0x60, 0x0a, 0x09, 0x44, 0x61, 0x74, 0x75, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x12,
	0x0a, 0x0a, 0x06, 0x52, 0x5f, 0x4e, 0x55, 0x4c, 0x4c, 0x10, 0x01, 0x12, 0x0a, 0x0a, 0x06, 0x52,
	0x5f, 0x42, 0x4f, 0x4f, 0x4c, 0x10, 0x02, 0x12, 0x09, 0x0a, 0x05, 0x52, 0x5f, 0x4e, 0x55, 0x4d,
	0x10, 0x03, 0x12, 0x09, 0x0a, 0x05, 0x52, 0x5f, 0x53, 0x54, 0x52, 0x10, 0x04, 0x12, 0x0b, 0x0a,
	0x07, 0x52, 0x5f, 0x41, 0x52, 0x52, 0x41, 0x59, 0x10, 0x05, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x5f,
	0x4f, 0x42, 0x4a, 0x45, 0x43, 0x54, 0x10, 0x06, 0x12, 0x0a, 0x0a, 0x06, 0x52, 0x5f, 0x4a, 0x53,
	0x4f, 0x4e, 0x10, 0x07, 0x22, 0xe6, 0x14, 0x0a, 0x04, 0x54, 0x65, 0x72, 0x6d, 0x12, 0x22, 0x0a,
	0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0e, 0x2e, 0x54, 0x65,
	0x72, 0x6d, 0x2e, 0x54, 0x65, 0x72, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70,
	0x65, 0x12, 0x1c, 0x0a, 0x05, 0x64, 0x61, 0x74, 0x75, 0x6d, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x06, 0x2e, 0x44, 0x61, 0x74, 0x75, 0x6d, 0x52, 0x05, 0x64, 0x61, 0x74, 0x75, 0x6d, 0x12,
	0x19, 0x0a, 0x04, 0x61, 0x72, 0x67, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x05, 0x2e,
	0x54, 0x65, 0x72, 0x6d, 0x52, 0x04, 0x61, 0x72, 0x67, 0x73, 0x12, 0x29, 0x0a, 0x07, 0x6f, 0x70,
	0x74, 0x61, 0x72, 0x67, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x54, 0x65,
	0x72, 0x6d, 0x2e, 0x41, 0x73, 0x73, 0x6f, 0x63, 0x50, 0x61, 0x69, 0x72, 0x52, 0x07, 0x6f, 0x70,
	0x74, 0x61, 0x72, 0x67, 0x73, 0x1a, 0x36, 0x0a, 0x09, 0x41, 0x73, 0x73, 0x6f, 0x63, 0x50, 0x61,
	0x69, 0x72, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x03, 0x6b, 0x65, 0x79, 0x12, 0x17, 0x0a, 0x03, 0x76, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x05, 0x2e, 0x54, 0x65, 0x72, 0x6d, 0x52, 0x03, 0x76, 0x61, 0x6c, 0x22, 0x9d, 0x13,
	0x0a, 0x08, 0x54, 0x65, 0x72, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x12, 0x09, 0x0a, 0x05, 0x44, 0x41,
	0x54, 0x55, 0x4d, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x4d, 0x41, 0x4b, 0x45, 0x5f, 0x41, 0x52,
	0x52, 0x41, 0x59, 0x10, 0x02, 0x12, 0x0c, 0x0a, 0x08, 0x4d, 0x41, 0x4b, 0x45, 0x5f, 0x4f, 0x42,
	0x4a, 0x10, 0x03, 0x12, 0x07, 0x0a, 0x03, 0x56, 0x41, 0x52, 0x10, 0x0a, 0x12, 0x0e, 0x0a, 0x0a,
	0x4a, 0x41, 0x56, 0x41, 0x53, 0x43, 0x52, 0x49, 0x50, 0x54, 0x10, 0x0b, 0x12, 0x09, 0x0a, 0x04,
	0x55, 0x55, 0x49, 0x44, 0x10, 0xa9, 0x01, 0x12, 0x09, 0x0a, 0x04, 0x48, 0x54, 0x54, 0x50, 0x10,
	0x99, 0x01, 0x12, 0x09, 0x0a, 0x05, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x0c, 0x12, 0x10, 0x0a,
	0x0c, 0x49, 0x4d, 0x50, 0x4c, 0x49, 0x43, 0x49, 0x54, 0x5f, 0x56, 0x41, 0x52, 0x10, 0x0d, 0x12,
	0x06, 0x0a, 0x02, 0x44, 0x42, 0x10, 0x0e, 0x12, 0x09, 0x0a, 0x05, 0x54, 0x41, 0x42, 0x4c, 0x45,
	0x10, 0x0f, 0x12, 0x07, 0x0a, 0x03, 0x47, 0x45, 0x54, 0x10, 0x10, 0x12, 0x0b, 0x0a, 0x07, 0x47,
	0x45, 0x54, 0x5f, 0x41, 0x4c, 0x4c, 0x10, 0x4e, 0x12, 0x06, 0x0a, 0x02, 0x45, 0x51, 0x10, 0x11,
	0x12, 0x06, 0x0a, 0x02, 0x4e, 0x45, 0x10, 0x12, 0x12, 0x06, 0x0a, 0x02, 0x4c, 0x54, 0x10, 0x13,
	0x12, 0x06, 0x0a, 0x02, 0x4c, 0x45, 0x10, 0x14, 0x12, 0x06, 0x0a, 0x02, 0x47, 0x54, 0x10, 0x15,
	0x12, 0x06, 0x0a, 0x02, 0x47, 0x45, 0x10, 0x16, 0x12, 0x07, 0x0a, 0x03, 0x4e, 0x4f, 0x54, 0x10,
	0x17, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x44, 0x44, 0x10, 0x18, 0x12, 0x07, 0x0a, 0x03, 0x53, 0x55,
	0x42, 0x10, 0x19, 0x12, 0x07, 0x0a, 0x03, 0x4d, 0x55, 0x4c, 0x10, 0x1a, 0x12, 0x07, 0x0a, 0x03,
	0x44, 0x49, 0x56, 0x10, 0x1b, 0x12, 0x07, 0x0a, 0x03, 0x4d, 0x4f, 0x44, 0x10, 0x1c, 0x12, 0x0a,
	0x0a, 0x05, 0x46, 0x4c, 0x4f, 0x4f, 0x52, 0x10, 0xb7, 0x01, 0x12, 0x09, 0x0a, 0x04, 0x43, 0x45,
	0x49, 0x4c, 0x10, 0xb8, 0x01, 0x12, 0x0a, 0x0a, 0x05, 0x52, 0x4f, 0x55, 0x4e, 0x44, 0x10, 0xb9,
	0x01, 0x12, 0x0a, 0x0a, 0x06, 0x41, 0x50, 0x50, 0x45, 0x4e, 0x44, 0x10, 0x1d, 0x12, 0x0b, 0x0a,
	0x07, 0x50, 0x52, 0x45, 0x50, 0x45, 0x4e, 0x44, 0x10, 0x50, 0x12, 0x0e, 0x0a, 0x0a, 0x44, 0x49,
	0x46, 0x46, 0x45, 0x52, 0x45, 0x4e, 0x43, 0x45, 0x10, 0x5f, 0x12, 0x0e, 0x0a, 0x0a, 0x53, 0x45,
	0x54, 0x5f, 0x49, 0x4e, 0x53, 0x45, 0x52, 0x54, 0x10, 0x58, 0x12, 0x14, 0x0a, 0x10, 0x53, 0x45,
	0x54, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x53, 0x45, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x59,
	0x12, 0x0d, 0x0a, 0x09, 0x53, 0x45, 0x54, 0x5f, 0x55, 0x4e, 0x49, 0x4f, 0x4e, 0x10, 0x5a, 0x12,
	0x12, 0x0a, 0x0e, 0x53, 0x45, 0x54, 0x5f, 0x44, 0x49, 0x46, 0x46, 0x45, 0x52, 0x45, 0x4e, 0x43,
	0x45, 0x10, 0x5b, 0x12, 0x09, 0x0a, 0x05, 0x53, 0x4c, 0x49, 0x43, 0x45, 0x10, 0x1e, 0x12, 0x08,
	0x0a, 0x04, 0x53, 0x4b, 0x49, 0x50, 0x10, 0x46, 0x12, 0x09, 0x0a, 0x05, 0x4c, 0x49, 0x4d, 0x49,
	0x54, 0x10, 0x47, 0x12, 0x0e, 0x0a, 0x0a, 0x4f, 0x46, 0x46, 0x53, 0x45, 0x54, 0x53, 0x5f, 0x4f,
	0x46, 0x10, 0x57, 0x12, 0x0c, 0x0a, 0x08, 0x43, 0x4f, 0x4e, 0x54, 0x41, 0x49, 0x4e, 0x53, 0x10,
	0x5d, 0x12, 0x0d, 0x0a, 0x09, 0x47, 0x45, 0x54, 0x5f, 0x46, 0x49, 0x45, 0x4c, 0x44, 0x10, 0x1f,
	0x12, 0x08, 0x0a, 0x04, 0x4b, 0x45, 0x59, 0x53, 0x10, 0x5e, 0x12, 0x0b, 0x0a, 0x06, 0x56, 0x41,
	0x4c, 0x55, 0x45, 0x53, 0x10, 0xba, 0x01, 0x12, 0x0b, 0x0a, 0x06, 0x4f, 0x42, 0x4a, 0x45, 0x43,
	0x54, 0x10, 0x8f, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x48, 0x41, 0x53, 0x5f, 0x46, 0x49, 0x45, 0x4c,
	0x44, 0x53, 0x10, 0x20, 0x12, 0x0f, 0x0a, 0x0b, 0x57, 0x49, 0x54, 0x48, 0x5f, 0x46, 0x49, 0x45,
	0x4c, 0x44, 0x53, 0x10, 0x60, 0x12, 0x09, 0x0a, 0x05, 0x50, 0x4c, 0x55, 0x43, 0x4b, 0x10, 0x21,
	0x12, 0x0b, 0x0a, 0x07, 0x57, 0x49, 0x54, 0x48, 0x4f, 0x55, 0x54, 0x10, 0x22, 0x12, 0x09, 0x0a,
	0x05, 0x4d, 0x45, 0x52, 0x47, 0x45, 0x10, 0x23, 0x12, 0x16, 0x0a, 0x12, 0x42, 0x45, 0x54, 0x57,
	0x45, 0x45, 0x4e, 0x5f, 0x44, 0x45, 0x50, 0x52, 0x45, 0x43, 0x41, 0x54, 0x45, 0x44, 0x10, 0x24,
	0x12, 0x0c, 0x0a, 0x07, 0x42, 0x45, 0x54, 0x57, 0x45, 0x45, 0x4e, 0x10, 0xb6, 0x01, 0x12, 0x0a,
	0x0a, 0x06, 0x52, 0x45, 0x44, 0x55, 0x43, 0x45, 0x10, 0x25, 0x12, 0x07, 0x0a, 0x03, 0x4d, 0x41,
	0x50, 0x10, 0x26, 0x12, 0x09, 0x0a, 0x04, 0x46, 0x4f, 0x4c, 0x44, 0x10, 0xbb, 0x01, 0x12, 0x0a,
	0x0a, 0x06, 0x46, 0x49, 0x4c, 0x54, 0x45, 0x52, 0x10, 0x27, 0x12, 0x0e, 0x0a, 0x0a, 0x43, 0x4f,
	0x4e, 0x43, 0x41, 0x54, 0x5f, 0x4d, 0x41, 0x50, 0x10, 0x28, 0x12, 0x0c, 0x0a, 0x08, 0x4f, 0x52,
	0x44, 0x45, 0x52, 0x5f, 0x42, 0x59, 0x10, 0x29, 0x12, 0x0c, 0x0a, 0x08, 0x44, 0x49, 0x53, 0x54,
	0x49, 0x4e, 0x43, 0x54, 0x10, 0x2a, 0x12, 0x09, 0x0a, 0x05, 0x43, 0x4f, 0x55, 0x4e, 0x54, 0x10,
	0x2b, 0x12, 0x0c, 0x0a, 0x08, 0x49, 0x53, 0x5f, 0x45, 0x4d, 0x50, 0x54, 0x59, 0x10, 0x56, 0x12,
	0x09, 0x0a, 0x05, 0x55, 0x4e, 0x49, 0x4f, 0x4e, 0x10, 0x2c, 0x12, 0x07, 0x0a, 0x03, 0x4e, 0x54,
	0x48, 0x10, 0x2d, 0x12, 0x0c, 0x0a, 0x07, 0x42, 0x52, 0x41, 0x43, 0x4b, 0x45, 0x54, 0x10, 0xaa,
	0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x49, 0x4e, 0x4e, 0x45, 0x52, 0x5f, 0x4a, 0x4f, 0x49, 0x4e, 0x10,
	0x30, 0x12, 0x0e, 0x0a, 0x0a, 0x4f, 0x55, 0x54, 0x45, 0x52, 0x5f, 0x4a, 0x4f, 0x49, 0x4e, 0x10,
	0x31, 0x12, 0x0b, 0x0a, 0x07, 0x45, 0x51, 0x5f, 0x4a, 0x4f, 0x49, 0x4e, 0x10, 0x32, 0x12, 0x07,
	0x0a, 0x03, 0x5a, 0x49, 0x50, 0x10, 0x48, 0x12, 0x0a, 0x0a, 0x05, 0x52, 0x41, 0x4e, 0x47, 0x45,
	0x10, 0xad, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x49, 0x4e, 0x53, 0x45, 0x52, 0x54, 0x5f, 0x41, 0x54,
	0x10, 0x52, 0x12, 0x0d, 0x0a, 0x09, 0x44, 0x45, 0x4c, 0x45, 0x54, 0x45, 0x5f, 0x41, 0x54, 0x10,
	0x53, 0x12, 0x0d, 0x0a, 0x09, 0x43, 0x48, 0x41, 0x4e, 0x47, 0x45, 0x5f, 0x41, 0x54, 0x10, 0x54,
	0x12, 0x0d, 0x0a, 0x09, 0x53, 0x50, 0x4c, 0x49, 0x43, 0x45, 0x5f, 0x41, 0x54, 0x10, 0x55, 0x12,
	0x0d, 0x0a, 0x09, 0x43, 0x4f, 0x45, 0x52, 0x43, 0x45, 0x5f, 0x54, 0x4f, 0x10, 0x33, 0x12, 0x0b,
	0x0a, 0x07, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f, 0x46, 0x10, 0x34, 0x12, 0x0a, 0x0a, 0x06, 0x55,
	0x50, 0x44, 0x41, 0x54, 0x45, 0x10, 0x35, 0x12, 0x0a, 0x0a, 0x06, 0x44, 0x45, 0x4c, 0x45, 0x54,
	0x45, 0x10, 0x36, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x45, 0x50, 0x4c, 0x41, 0x43, 0x45, 0x10, 0x37,
	0x12, 0x0a, 0x0a, 0x06, 0x49, 0x4e, 0x53, 0x45, 0x52, 0x54, 0x10, 0x38, 0x12, 0x0d, 0x0a, 0x09,
	0x44, 0x42, 0x5f, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x10, 0x39, 0x12, 0x0b, 0x0a, 0x07, 0x44,
	0x42, 0x5f, 0x44, 0x52, 0x4f, 0x50, 0x10, 0x3a, 0x12, 0x0b, 0x0a, 0x07, 0x44, 0x42, 0x5f, 0x4c,
	0x49, 0x53, 0x54, 0x10, 0x3b, 0x12, 0x10, 0x0a, 0x0c, 0x54, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x43,
	0x52, 0x45, 0x41, 0x54, 0x45, 0x10, 0x3c, 0x12, 0x0e, 0x0a, 0x0a, 0x54, 0x41, 0x42, 0x4c, 0x45,
	0x5f, 0x44, 0x52, 0x4f, 0x50, 0x10, 0x3d, 0x12, 0x0e, 0x0a, 0x0a, 0x54, 0x41, 0x42, 0x4c, 0x45,
	0x5f, 0x4c, 0x49, 0x53, 0x54, 0x10, 0x3e, 0x12, 0x0b, 0x0a, 0x06, 0x43, 0x4f, 0x4e, 0x46, 0x49,
	0x47, 0x10, 0xae, 0x01, 0x12, 0x0b, 0x0a, 0x06, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x10, 0xaf,
	0x01, 0x12, 0x09, 0x0a, 0x04, 0x57, 0x41, 0x49, 0x54, 0x10, 0xb1, 0x01, 0x12, 0x10, 0x0a, 0x0b,
	0x52, 0x45, 0x43, 0x4f, 0x4e, 0x46, 0x49, 0x47, 0x55, 0x52, 0x45, 0x10, 0xb0, 0x01, 0x12, 0x0e,
	0x0a, 0x09, 0x52, 0x45, 0x42, 0x41, 0x4c, 0x41, 0x4e, 0x43, 0x45, 0x10, 0xb3, 0x01, 0x12, 0x09,
	0x0a, 0x04, 0x53, 0x59, 0x4e, 0x43, 0x10, 0x8a, 0x01, 0x12, 0x0a, 0x0a, 0x05, 0x47, 0x52, 0x41,
	0x4e, 0x54, 0x10, 0xbc, 0x01, 0x12, 0x10, 0x0a, 0x0c, 0x49, 0x4e, 0x44, 0x45, 0x58, 0x5f, 0x43,
	0x52, 0x45, 0x41, 0x54, 0x45, 0x10, 0x4b, 0x12, 0x0e, 0x0a, 0x0a, 0x49, 0x4e, 0x44, 0x45, 0x58,
	0x5f, 0x44, 0x52, 0x4f, 0x50, 0x10, 0x4c, 0x12, 0x0e, 0x0a, 0x0a, 0x49, 0x4e, 0x44, 0x45, 0x58,
	0x5f, 0x4c, 0x49, 0x53, 0x54, 0x10, 0x4d, 0x12, 0x11, 0x0a, 0x0c, 0x49, 0x4e, 0x44, 0x45, 0x58,
	0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x10, 0x8b, 0x01, 0x12, 0x0f, 0x0a, 0x0a, 0x49, 0x4e,
	0x44, 0x45, 0x58, 0x5f, 0x57, 0x41, 0x49, 0x54, 0x10, 0x8c, 0x01, 0x12, 0x11, 0x0a, 0x0c, 0x49,
	0x4e, 0x44, 0x45, 0x58, 0x5f, 0x52, 0x45, 0x4e, 0x41, 0x4d, 0x45, 0x10, 0x9c, 0x01, 0x12, 0x13,
	0x0a, 0x0e, 0x53, 0x45, 0x54, 0x5f, 0x57, 0x52, 0x49, 0x54, 0x45, 0x5f, 0x48, 0x4f, 0x4f, 0x4b,
	0x10, 0xbd, 0x01, 0x12, 0x13, 0x0a, 0x0e, 0x47, 0x45, 0x54, 0x5f, 0x57, 0x52, 0x49, 0x54, 0x45,
	0x5f, 0x48, 0x4f, 0x4f, 0x4b, 0x10, 0xbe, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x46, 0x55, 0x4e, 0x43,
	0x41, 0x4c, 0x4c, 0x10, 0x40, 0x12, 0x0a, 0x0a, 0x06, 0x42, 0x52, 0x41, 0x4e, 0x43, 0x48, 0x10,
	0x41, 0x12, 0x06, 0x0a, 0x02, 0x4f, 0x52, 0x10, 0x42, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x4e, 0x44,
	0x10, 0x43, 0x12, 0x0c, 0x0a, 0x08, 0x46, 0x4f, 0x52, 0x5f, 0x45, 0x41, 0x43, 0x48, 0x10, 0x44,
	0x12, 0x08, 0x0a, 0x04, 0x46, 0x55, 0x4e, 0x43, 0x10, 0x45, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x53,
	0x43, 0x10, 0x49, 0x12, 0x08, 0x0a, 0x04, 0x44, 0x45, 0x53, 0x43, 0x10, 0x4a, 0x12, 0x08, 0x0a,
	0x04, 0x49, 0x4e, 0x46, 0x4f, 0x10, 0x4f, 0x12, 0x09, 0x0a, 0x05, 0x4d, 0x41, 0x54, 0x43, 0x48,
	0x10, 0x61, 0x12, 0x0b, 0x0a, 0x06, 0x55, 0x50, 0x43, 0x41, 0x53, 0x45, 0x10, 0x8d, 0x01, 0x12,
	0x0d, 0x0a, 0x08, 0x44, 0x4f, 0x57, 0x4e, 0x43, 0x41, 0x53, 0x45, 0x10, 0x8e, 0x01, 0x12, 0x0a,
	0x0a, 0x06, 0x53, 0x41, 0x4d, 0x50, 0x4c, 0x45, 0x10, 0x51, 0x12, 0x0b, 0x0a, 0x07, 0x44, 0x45,
	0x46, 0x41, 0x55, 0x4c, 0x54, 0x10, 0x5c, 0x12, 0x08, 0x0a, 0x04, 0x4a, 0x53, 0x4f, 0x4e, 0x10,
	0x62, 0x12, 0x0b, 0x0a, 0x07, 0x49, 0x53, 0x4f, 0x38, 0x36, 0x30, 0x31, 0x10, 0x63, 0x12, 0x0e,
	0x0a, 0x0a, 0x54, 0x4f, 0x5f, 0x49, 0x53, 0x4f, 0x38, 0x36, 0x30, 0x31, 0x10, 0x64, 0x12, 0x0e,
	0x0a, 0x0a, 0x45, 0x50, 0x4f, 0x43, 0x48, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x10, 0x65, 0x12, 0x11,
	0x0a, 0x0d, 0x54, 0x4f, 0x5f, 0x45, 0x50, 0x4f, 0x43, 0x48, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x10,
	0x66, 0x12, 0x07, 0x0a, 0x03, 0x4e, 0x4f, 0x57, 0x10, 0x67, 0x12, 0x0f, 0x0a, 0x0b, 0x49, 0x4e,
	0x5f, 0x54, 0x49, 0x4d, 0x45, 0x5a, 0x4f, 0x4e, 0x45, 0x10, 0x68, 0x12, 0x0a, 0x0a, 0x06, 0x44,
	0x55, 0x52, 0x49, 0x4e, 0x47, 0x10, 0x69, 0x12, 0x08, 0x0a, 0x04, 0x44, 0x41, 0x54, 0x45, 0x10,
	0x6a, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x49, 0x4d, 0x45, 0x5f, 0x4f, 0x46, 0x5f, 0x44, 0x41, 0x59,
	0x10, 0x7e, 0x12, 0x0c, 0x0a, 0x08, 0x54, 0x49, 0x4d, 0x45, 0x5a, 0x4f, 0x4e, 0x45, 0x10, 0x7f,
	0x12, 0x09, 0x0a, 0x04, 0x59, 0x45, 0x41, 0x52, 0x10, 0x80, 0x01, 0x12, 0x0a, 0x0a, 0x05, 0x4d,
	0x4f, 0x4e, 0x54, 0x48, 0x10, 0x81, 0x01, 0x12, 0x08, 0x0a, 0x03, 0x44, 0x41, 0x59, 0x10, 0x82,
	0x01, 0x12, 0x10, 0x0a, 0x0b, 0x44, 0x41, 0x59, 0x5f, 0x4f, 0x46, 0x5f, 0x57, 0x45, 0x45, 0x4b,
	0x10, 0x83, 0x01, 0x12, 0x10, 0x0a, 0x0b, 0x44, 0x41, 0x59, 0x5f, 0x4f, 0x46, 0x5f, 0x59, 0x45,
	0x41, 0x52, 0x10, 0x84, 0x01, 0x12, 0x0a, 0x0a, 0x05, 0x48, 0x4f, 0x55, 0x52, 0x53, 0x10, 0x85,
	0x01, 0x12, 0x0c, 0x0a, 0x07, 0x4d, 0x49, 0x4e, 0x55, 0x54, 0x45, 0x53, 0x10, 0x86, 0x01, 0x12,
	0x0c, 0x0a, 0x07, 0x53, 0x45, 0x43, 0x4f, 0x4e, 0x44, 0x53, 0x10, 0x87, 0x01, 0x12, 0x09, 0x0a,
	0x04, 0x54, 0x49, 0x4d, 0x45, 0x10, 0x88, 0x01, 0x12, 0x0a, 0x0a, 0x06, 0x4d, 0x4f, 0x4e, 0x44,
	0x41, 0x59, 0x10, 0x6b, 0x12, 0x0b, 0x0a, 0x07, 0x54, 0x55, 0x45, 0x53, 0x44, 0x41, 0x59, 0x10,
	0x6c, 0x12, 0x0d, 0x0a, 0x09, 0x57, 0x45, 0x44, 0x4e, 0x45, 0x53, 0x44, 0x41, 0x59, 0x10, 0x6d,
	0x12, 0x0c, 0x0a, 0x08, 0x54, 0x48, 0x55, 0x52, 0x53, 0x44, 0x41, 0x59, 0x10, 0x6e, 0x12, 0x0a,
	0x0a, 0x06, 0x46, 0x52, 0x49, 0x44, 0x41, 0x59, 0x10, 0x6f, 0x12, 0x0c, 0x0a, 0x08, 0x53, 0x41,
	0x54, 0x55, 0x52, 0x44, 0x41, 0x59, 0x10, 0x70, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x55, 0x4e, 0x44,
	0x41, 0x59, 0x10, 0x71, 0x12, 0x0b, 0x0a, 0x07, 0x4a, 0x41, 0x4e, 0x55, 0x41, 0x52, 0x59, 0x10,
	0x72, 0x12, 0x0c, 0x0a, 0x08, 0x46, 0x45, 0x42, 0x52, 0x55, 0x41, 0x52, 0x59, 0x10, 0x73, 0x12,
	0x09, 0x0a, 0x05, 0x4d, 0x41, 0x52, 0x43, 0x48, 0x10, 0x74, 0x12, 0x09, 0x0a, 0x05, 0x41, 0x50,
	0x52, 0x49, 0x4c, 0x10, 0x75, 0x12, 0x07, 0x0a, 0x03, 0x4d, 0x41, 0x59, 0x10, 0x76, 0x12, 0x08,
	0x0a, 0x04, 0x4a, 0x55, 0x4e, 0x45, 0x10, 0x77, 0x12, 0x08, 0x0a, 0x04, 0x4a, 0x55, 0x4c, 0x59,
	0x10, 0x78, 0x12, 0x0a, 0x0a, 0x06, 0x41, 0x55, 0x47, 0x55, 0x53, 0x54, 0x10, 0x79, 0x12, 0x0d,
	0x0a, 0x09, 0x53, 0x45, 0x50, 0x54, 0x45, 0x4d, 0x42, 0x45, 0x52, 0x10, 0x7a, 0x12, 0x0b, 0x0a,
	0x07, 0x4f, 0x43, 0x54, 0x4f, 0x42, 0x45, 0x52, 0x10, 0x7b, 0x12, 0x0c, 0x0a, 0x08, 0x4e, 0x4f,
	0x56, 0x45, 0x4d, 0x42, 0x45, 0x52, 0x10, 0x7c, 0x12, 0x0c, 0x0a, 0x08, 0x44, 0x45, 0x43, 0x45,
	0x4d, 0x42, 0x45, 0x52, 0x10, 0x7d, 0x12, 0x0c, 0x0a, 0x07, 0x4c, 0x49, 0x54, 0x45, 0x52, 0x41,
	0x4c, 0x10, 0x89, 0x01, 0x12, 0x0a, 0x0a, 0x05, 0x47, 0x52, 0x4f, 0x55, 0x50, 0x10, 0x90, 0x01,
	0x12, 0x08, 0x0a, 0x03, 0x53, 0x55, 0x4d, 0x10, 0x91, 0x01, 0x12, 0x08, 0x0a, 0x03, 0x41, 0x56,
	0x47, 0x10, 0x92, 0x01, 0x12, 0x08, 0x0a, 0x03, 0x4d, 0x49, 0x4e, 0x10, 0x93, 0x01, 0x12, 0x08,
	0x0a, 0x03, 0x4d, 0x41, 0x58, 0x10, 0x94, 0x01, 0x12, 0x0a, 0x0a, 0x05, 0x53, 0x50, 0x4c, 0x49,
	0x54, 0x10, 0x95, 0x01, 0x12, 0x0c, 0x0a, 0x07, 0x55, 0x4e, 0x47, 0x52, 0x4f, 0x55, 0x50, 0x10,
	0x96, 0x01, 0x12, 0x0b, 0x0a, 0x06, 0x52, 0x41, 0x4e, 0x44, 0x4f, 0x4d, 0x10, 0x97, 0x01, 0x12,
	0x0c, 0x0a, 0x07, 0x43, 0x48, 0x41, 0x4e, 0x47, 0x45, 0x53, 0x10, 0x98, 0x01, 0x12, 0x09, 0x0a,
	0x04, 0x41, 0x52, 0x47, 0x53, 0x10, 0x9a, 0x01, 0x12, 0x0b, 0x0a, 0x06, 0x42, 0x49, 0x4e, 0x41,
	0x52, 0x59, 0x10, 0x9b, 0x01, 0x12, 0x0c, 0x0a, 0x07, 0x47, 0x45, 0x4f, 0x4a, 0x53, 0x4f, 0x4e,
	0x10, 0x9d, 0x01, 0x12, 0x0f, 0x0a, 0x0a, 0x54, 0x4f, 0x5f, 0x47, 0x45, 0x4f, 0x4a, 0x53, 0x4f,
	0x4e, 0x10, 0x9e, 0x01, 0x12, 0x0a, 0x0a, 0x05, 0x50, 0x4f, 0x49, 0x4e, 0x54, 0x10, 0x9f, 0x01,
	0x12, 0x09, 0x0a, 0x04, 0x4c, 0x49, 0x4e, 0x45, 0x10, 0xa0, 0x01, 0x12, 0x0c, 0x0a, 0x07, 0x50,
	0x4f, 0x4c, 0x59, 0x47, 0x4f, 0x4e, 0x10, 0xa1, 0x01, 0x12, 0x0d, 0x0a, 0x08, 0x44, 0x49, 0x53,
	0x54, 0x41, 0x4e, 0x43, 0x45, 0x10, 0xa2, 0x01, 0x12, 0x0f, 0x0a, 0x0a, 0x49, 0x4e, 0x54, 0x45,
	0x52, 0x53, 0x45, 0x43, 0x54, 0x53, 0x10, 0xa3, 0x01, 0x12, 0x0d, 0x0a, 0x08, 0x49, 0x4e, 0x43,
	0x4c, 0x55, 0x44, 0x45, 0x53, 0x10, 0xa4, 0x01, 0x12, 0x0b, 0x0a, 0x06, 0x43, 0x49, 0x52, 0x43,
	0x4c, 0x45, 0x10, 0xa5, 0x01, 0x12, 0x15, 0x0a, 0x10, 0x47, 0x45, 0x54, 0x5f, 0x49, 0x4e, 0x54,
	0x45, 0x52, 0x53, 0x45, 0x43, 0x54, 0x49, 0x4e, 0x47, 0x10, 0xa6, 0x01, 0x12, 0x09, 0x0a, 0x04,
	0x46, 0x49, 0x4c, 0x4c, 0x10, 0xa7, 0x01, 0x12, 0x10, 0x0a, 0x0b, 0x47, 0x45, 0x54, 0x5f, 0x4e,
	0x45, 0x41, 0x52, 0x45, 0x53, 0x54, 0x10, 0xa8, 0x01, 0x12, 0x10, 0x0a, 0x0b, 0x50, 0x4f, 0x4c,
	0x59, 0x47, 0x4f, 0x4e, 0x5f, 0x53, 0x55, 0x42, 0x10, 0xab, 0x01, 0x12, 0x13, 0x0a, 0x0e, 0x54,
	0x4f, 0x5f, 0x4a, 0x53, 0x4f, 0x4e, 0x5f, 0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x10, 0xac, 0x01,
	0x12, 0x0b, 0x0a, 0x06, 0x4d, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x10, 0xb4, 0x01, 0x12, 0x0b, 0x0a,
	0x06, 0x4d, 0x41, 0x58, 0x56, 0x41, 0x4c, 0x10, 0xb5, 0x01, 0x12, 0x0c, 0x0a, 0x07, 0x42, 0x49,
	0x54, 0x5f, 0x41, 0x4e, 0x44, 0x10, 0xbf, 0x01, 0x12, 0x0b, 0x0a, 0x06, 0x42, 0x49, 0x54, 0x5f,
	0x4f, 0x52, 0x10, 0xc0, 0x01, 0x12, 0x0c, 0x0a, 0x07, 0x42, 0x49, 0x54, 0x5f, 0x58, 0x4f, 0x52,
	0x10, 0xc1, 0x01, 0x12, 0x0c, 0x0a, 0x07, 0x42, 0x49, 0x54, 0x5f, 0x4e, 0x4f, 0x54, 0x10, 0xc2,
	0x01, 0x12, 0x0c, 0x0a, 0x07, 0x42, 0x49, 0x54, 0x5f, 0x53, 0x41, 0x4c, 0x10, 0xc3, 0x01, 0x12,
	0x0c, 0x0a, 0x07, 0x42, 0x49, 0x54, 0x5f, 0x53, 0x41, 0x52, 0x10, 0xc4, 0x01, 0x42, 0x07, 0x5a,
	0x05, 0x2e, 0x2f, 0x71, 0x6c, 0x32,
}

var (
	file_ql2_proto_rawDescOnce sync.Once
	file_ql2_proto_rawDescData = file_ql2_proto_rawDesc
)

func file_ql2_proto_rawDescGZIP() []byte {
	file_ql2_proto_rawDescOnce.Do(func() {
		file_ql2_proto_rawDescData = protoimpl.X.CompressGZIP(file_ql2_proto_rawDescData)
	})
	return file_ql2_proto_rawDescData
}

var file_ql2_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_ql2_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_ql2_proto_goTypes = []interface{}{
	(VersionDummy_Version)(0),  // 0: VersionDummy.Version
	(VersionDummy_Protocol)(0), // 1: VersionDummy.Protocol
	(Query_QueryType)(0),       // 2: Query.QueryType
	(Frame_FrameType)(0),       // 3: Frame.FrameType
	(Response_ResponseType)(0), // 4: Response.ResponseType
	(Response_ErrorType)(0),    // 5: Response.ErrorType
	(Response_ResponseNote)(0), // 6: Response.ResponseNote
	(Datum_DatumType)(0),       // 7: Datum.DatumType
	(Term_TermType)(0),         // 8: Term.TermType
	(*VersionDummy)(nil),       // 9: VersionDummy
	(*Query)(nil),              // 10: Query
	(*Frame)(nil),              // 11: Frame
	(*Backtrace)(nil),          // 12: Backtrace
	(*Response)(nil),           // 13: Response
	(*Datum)(nil),              // 14: Datum
	(*Term)(nil),               // 15: Term
	(*Query_AssocPair)(nil),    // 16: Query.AssocPair
	(*Datum_AssocPair)(nil),    // 17: Datum.AssocPair
	(*Term_AssocPair)(nil),     // 18: Term.AssocPair
}
var file_ql2_proto_depIdxs = []int32{
	2,  // 0: Query.type:type_name -> Query.QueryType
	15, // 1: Query.query:type_name -> Term
	16, // 2: Query.global_optargs:type_name -> Query.AssocPair
	3,  // 3: Frame.type:type_name -> Frame.FrameType
	11, // 4: Backtrace.frames:type_name -> Frame
	4,  // 5: Response.type:type_name -> Response.ResponseType
	5,  // 6: Response.error_type:type_name -> Response.ErrorType
	6,  // 7: Response.notes:type_name -> Response.ResponseNote
	14, // 8: Response.response:type_name -> Datum
	12, // 9: Response.backtrace:type_name -> Backtrace
	14, // 10: Response.profile:type_name -> Datum
	7,  // 11: Datum.type:type_name -> Datum.DatumType
	14, // 12: Datum.r_array:type_name -> Datum
	17, // 13: Datum.r_object:type_name -> Datum.AssocPair
	8,  // 14: Term.type:type_name -> Term.TermType
	14, // 15: Term.datum:type_name -> Datum
	15, // 16: Term.args:type_name -> Term
	18, // 17: Term.optargs:type_name -> Term.AssocPair
	15, // 18: Query.AssocPair.val:type_name -> Term
	14, // 19: Datum.AssocPair.val:type_name -> Datum
	15, // 20: Term.AssocPair.val:type_name -> Term
	21, // [21:21] is the sub-list for method output_type
	21, // [21:21] is the sub-list for method input_type
	21, // [21:21] is the sub-list for extension type_name
	21, // [21:21] is the sub-list for extension extendee
	0,  // [0:21] is the sub-list for field type_name
}

func init() { file_ql2_proto_init() }
func file_ql2_proto_init() {
	if File_ql2_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_ql2_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VersionDummy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ql2_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Query); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ql2_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Frame); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ql2_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Backtrace); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ql2_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Response); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ql2_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Datum); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ql2_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Term); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ql2_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Query_AssocPair); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ql2_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Datum_AssocPair); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ql2_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Term_AssocPair); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_ql2_proto_rawDesc,
			NumEnums:      9,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_ql2_proto_goTypes,
		DependencyIndexes: file_ql2_proto_depIdxs,
		EnumInfos:         file_ql2_proto_enumTypes,
		MessageInfos:      file_ql2_proto_msgTypes,
	}.Build()
	File_ql2_proto = out.File
	file_ql2_proto_rawDesc = nil
	file_ql2_proto_goTypes = nil
	file_ql2_proto_depIdxs = nil
}
