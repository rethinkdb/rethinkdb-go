// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ql2.proto

package ql2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// non-conforming protobuf libraries
// This enum contains the magic numbers for your version.  See **THE HIGH-LEVEL
// VIEW** for what to do with it.
type VersionDummy_Version int32

const (
	VersionDummy_V0_1 VersionDummy_Version = 1063369270
	VersionDummy_V0_2 VersionDummy_Version = 1915781601
	VersionDummy_V0_3 VersionDummy_Version = 1601562686
	VersionDummy_V0_4 VersionDummy_Version = 1074539808
	VersionDummy_V1_0 VersionDummy_Version = 885177795
)

var VersionDummy_Version_name = map[int32]string{
	1063369270: "V0_1",
	1915781601: "V0_2",
	1601562686: "V0_3",
	1074539808: "V0_4",
	885177795:  "V1_0",
}
var VersionDummy_Version_value = map[string]int32{
	"V0_1": 1063369270,
	"V0_2": 1915781601,
	"V0_3": 1601562686,
	"V0_4": 1074539808,
	"V1_0": 885177795,
}

func (x VersionDummy_Version) Enum() *VersionDummy_Version {
	p := new(VersionDummy_Version)
	*p = x
	return p
}
func (x VersionDummy_Version) String() string {
	return proto.EnumName(VersionDummy_Version_name, int32(x))
}
func (x *VersionDummy_Version) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VersionDummy_Version_value, data, "VersionDummy_Version")
	if err != nil {
		return err
	}
	*x = VersionDummy_Version(value)
	return nil
}
func (VersionDummy_Version) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{0, 0}
}

// The protocol to use after the handshake, specified in V0_3
type VersionDummy_Protocol int32

const (
	VersionDummy_PROTOBUF VersionDummy_Protocol = 656407617
	VersionDummy_JSON     VersionDummy_Protocol = 2120839367
)

var VersionDummy_Protocol_name = map[int32]string{
	656407617:  "PROTOBUF",
	2120839367: "JSON",
}
var VersionDummy_Protocol_value = map[string]int32{
	"PROTOBUF": 656407617,
	"JSON":     2120839367,
}

func (x VersionDummy_Protocol) Enum() *VersionDummy_Protocol {
	p := new(VersionDummy_Protocol)
	*p = x
	return p
}
func (x VersionDummy_Protocol) String() string {
	return proto.EnumName(VersionDummy_Protocol_name, int32(x))
}
func (x *VersionDummy_Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VersionDummy_Protocol_value, data, "VersionDummy_Protocol")
	if err != nil {
		return err
	}
	*x = VersionDummy_Protocol(value)
	return nil
}
func (VersionDummy_Protocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{0, 1}
}

type Query_QueryType int32

const (
	Query_START    Query_QueryType = 1
	Query_CONTINUE Query_QueryType = 2
	// (see [Response]).
	Query_STOP         Query_QueryType = 3
	Query_NOREPLY_WAIT Query_QueryType = 4
	Query_SERVER_INFO  Query_QueryType = 5
)

var Query_QueryType_name = map[int32]string{
	1: "START",
	2: "CONTINUE",
	3: "STOP",
	4: "NOREPLY_WAIT",
	5: "SERVER_INFO",
}
var Query_QueryType_value = map[string]int32{
	"START":        1,
	"CONTINUE":     2,
	"STOP":         3,
	"NOREPLY_WAIT": 4,
	"SERVER_INFO":  5,
}

func (x Query_QueryType) Enum() *Query_QueryType {
	p := new(Query_QueryType)
	*p = x
	return p
}
func (x Query_QueryType) String() string {
	return proto.EnumName(Query_QueryType_name, int32(x))
}
func (x *Query_QueryType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Query_QueryType_value, data, "Query_QueryType")
	if err != nil {
		return err
	}
	*x = Query_QueryType(value)
	return nil
}
func (Query_QueryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{1, 0}
}

type Frame_FrameType int32

const (
	Frame_POS Frame_FrameType = 1
	Frame_OPT Frame_FrameType = 2
)

var Frame_FrameType_name = map[int32]string{
	1: "POS",
	2: "OPT",
}
var Frame_FrameType_value = map[string]int32{
	"POS": 1,
	"OPT": 2,
}

func (x Frame_FrameType) Enum() *Frame_FrameType {
	p := new(Frame_FrameType)
	*p = x
	return p
}
func (x Frame_FrameType) String() string {
	return proto.EnumName(Frame_FrameType_name, int32(x))
}
func (x *Frame_FrameType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Frame_FrameType_value, data, "Frame_FrameType")
	if err != nil {
		return err
	}
	*x = Frame_FrameType(value)
	return nil
}
func (Frame_FrameType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{2, 0}
}

type Response_ResponseType int32

const (
	// These response types indicate success.
	Response_SUCCESS_ATOM     Response_ResponseType = 1
	Response_SUCCESS_SEQUENCE Response_ResponseType = 2
	Response_SUCCESS_PARTIAL  Response_ResponseType = 3
	// datatypes.  If you send a [CONTINUE] query with
	// the same token as this response, you will get
	// more of the sequence.  Keep sending [CONTINUE]
	// queries until you get back [SUCCESS_SEQUENCE].
	Response_WAIT_COMPLETE Response_ResponseType = 4
	Response_SERVER_INFO   Response_ResponseType = 5
	// These response types indicate failure.
	Response_CLIENT_ERROR Response_ResponseType = 16
	// client sends a malformed protobuf, or tries to
	// send [CONTINUE] for an unknown token.
	Response_COMPILE_ERROR Response_ResponseType = 17
	// checking.  For example, if you pass too many
	// arguments to a function.
	Response_RUNTIME_ERROR Response_ResponseType = 18
)

var Response_ResponseType_name = map[int32]string{
	1:  "SUCCESS_ATOM",
	2:  "SUCCESS_SEQUENCE",
	3:  "SUCCESS_PARTIAL",
	4:  "WAIT_COMPLETE",
	5:  "SERVER_INFO",
	16: "CLIENT_ERROR",
	17: "COMPILE_ERROR",
	18: "RUNTIME_ERROR",
}
var Response_ResponseType_value = map[string]int32{
	"SUCCESS_ATOM":     1,
	"SUCCESS_SEQUENCE": 2,
	"SUCCESS_PARTIAL":  3,
	"WAIT_COMPLETE":    4,
	"SERVER_INFO":      5,
	"CLIENT_ERROR":     16,
	"COMPILE_ERROR":    17,
	"RUNTIME_ERROR":    18,
}

func (x Response_ResponseType) Enum() *Response_ResponseType {
	p := new(Response_ResponseType)
	*p = x
	return p
}
func (x Response_ResponseType) String() string {
	return proto.EnumName(Response_ResponseType_name, int32(x))
}
func (x *Response_ResponseType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Response_ResponseType_value, data, "Response_ResponseType")
	if err != nil {
		return err
	}
	*x = Response_ResponseType(value)
	return nil
}
func (Response_ResponseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{4, 0}
}

// If `ResponseType` is `RUNTIME_ERROR`, this may be filled in with more
// information about the error.
type Response_ErrorType int32

const (
	Response_INTERNAL         Response_ErrorType = 1000000
	Response_RESOURCE_LIMIT   Response_ErrorType = 2000000
	Response_QUERY_LOGIC      Response_ErrorType = 3000000
	Response_NON_EXISTENCE    Response_ErrorType = 3100000
	Response_OP_FAILED        Response_ErrorType = 4100000
	Response_OP_INDETERMINATE Response_ErrorType = 4200000
	Response_USER             Response_ErrorType = 5000000
	Response_PERMISSION_ERROR Response_ErrorType = 6000000
)

var Response_ErrorType_name = map[int32]string{
	1000000: "INTERNAL",
	2000000: "RESOURCE_LIMIT",
	3000000: "QUERY_LOGIC",
	3100000: "NON_EXISTENCE",
	4100000: "OP_FAILED",
	4200000: "OP_INDETERMINATE",
	5000000: "USER",
	6000000: "PERMISSION_ERROR",
}
var Response_ErrorType_value = map[string]int32{
	"INTERNAL":         1000000,
	"RESOURCE_LIMIT":   2000000,
	"QUERY_LOGIC":      3000000,
	"NON_EXISTENCE":    3100000,
	"OP_FAILED":        4100000,
	"OP_INDETERMINATE": 4200000,
	"USER":             5000000,
	"PERMISSION_ERROR": 6000000,
}

func (x Response_ErrorType) Enum() *Response_ErrorType {
	p := new(Response_ErrorType)
	*p = x
	return p
}
func (x Response_ErrorType) String() string {
	return proto.EnumName(Response_ErrorType_name, int32(x))
}
func (x *Response_ErrorType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Response_ErrorType_value, data, "Response_ErrorType")
	if err != nil {
		return err
	}
	*x = Response_ErrorType(value)
	return nil
}
func (Response_ErrorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{4, 1}
}

// ResponseNotes are used to provide information about the query
// response that may be useful for people writing drivers or ORMs.
// Currently all the notes we send indicate that a stream has certain
// special properties.
type Response_ResponseNote int32

const (
	// The stream is a changefeed stream (e.g. `r.table('test').changes()`).
	Response_SEQUENCE_FEED Response_ResponseNote = 1
	// The stream is a point changefeed stream
	// (e.g. `r.table('test').get(0).changes()`).
	Response_ATOM_FEED Response_ResponseNote = 2
	// The stream is an order_by_limit changefeed stream
	// (e.g. `r.table('test').order_by(index: 'id').limit(5).changes()`).
	Response_ORDER_BY_LIMIT_FEED Response_ResponseNote = 3
	// The stream is a union of multiple changefeed types that can't be
	// collapsed to a single type
	// (e.g. `r.table('test').changes().union(r.table('test').get(0).changes())`).
	Response_UNIONED_FEED Response_ResponseNote = 4
	// The stream is a changefeed stream and includes notes on what state
	// the changefeed stream is in (e.g. objects of the form `{state:
	// 'initializing'}`).
	Response_INCLUDES_STATES Response_ResponseNote = 5
)

var Response_ResponseNote_name = map[int32]string{
	1: "SEQUENCE_FEED",
	2: "ATOM_FEED",
	3: "ORDER_BY_LIMIT_FEED",
	4: "UNIONED_FEED",
	5: "INCLUDES_STATES",
}
var Response_ResponseNote_value = map[string]int32{
	"SEQUENCE_FEED":       1,
	"ATOM_FEED":           2,
	"ORDER_BY_LIMIT_FEED": 3,
	"UNIONED_FEED":        4,
	"INCLUDES_STATES":     5,
}

func (x Response_ResponseNote) Enum() *Response_ResponseNote {
	p := new(Response_ResponseNote)
	*p = x
	return p
}
func (x Response_ResponseNote) String() string {
	return proto.EnumName(Response_ResponseNote_name, int32(x))
}
func (x *Response_ResponseNote) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Response_ResponseNote_value, data, "Response_ResponseNote")
	if err != nil {
		return err
	}
	*x = Response_ResponseNote(value)
	return nil
}
func (Response_ResponseNote) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{4, 2}
}

type Datum_DatumType int32

const (
	Datum_R_NULL   Datum_DatumType = 1
	Datum_R_BOOL   Datum_DatumType = 2
	Datum_R_NUM    Datum_DatumType = 3
	Datum_R_STR    Datum_DatumType = 4
	Datum_R_ARRAY  Datum_DatumType = 5
	Datum_R_OBJECT Datum_DatumType = 6
	// This [DatumType] will only be used if [accepts_r_json] is
	// set to [true] in [Query].  [r_str] will be filled with a
	// JSON encoding of the [Datum].
	Datum_R_JSON Datum_DatumType = 7
)

var Datum_DatumType_name = map[int32]string{
	1: "R_NULL",
	2: "R_BOOL",
	3: "R_NUM",
	4: "R_STR",
	5: "R_ARRAY",
	6: "R_OBJECT",
	7: "R_JSON",
}
var Datum_DatumType_value = map[string]int32{
	"R_NULL":   1,
	"R_BOOL":   2,
	"R_NUM":    3,
	"R_STR":    4,
	"R_ARRAY":  5,
	"R_OBJECT": 6,
	"R_JSON":   7,
}

func (x Datum_DatumType) Enum() *Datum_DatumType {
	p := new(Datum_DatumType)
	*p = x
	return p
}
func (x Datum_DatumType) String() string {
	return proto.EnumName(Datum_DatumType_name, int32(x))
}
func (x *Datum_DatumType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Datum_DatumType_value, data, "Datum_DatumType")
	if err != nil {
		return err
	}
	*x = Datum_DatumType(value)
	return nil
}
func (Datum_DatumType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{5, 0}
}

type Term_TermType int32

const (
	// A RQL datum, stored in `datum` below.
	Term_DATUM      Term_TermType = 1
	Term_MAKE_ARRAY Term_TermType = 2
	// Evaluate the terms in [optargs] and make an object
	Term_MAKE_OBJ Term_TermType = 3
	// Takes an integer representing a variable and returns the value stored
	// in that variable.  It's the responsibility of the client to translate
	// from their local representation of a variable to a unique _non-negative_
	// integer for that variable.  (We do it this way instead of letting
	// clients provide variable names as strings to discourage
	// variable-capturing client libraries, and because it's more efficient
	// on the wire.)
	Term_VAR Term_TermType = 10
	// Takes some javascript code and executes it.
	Term_JAVASCRIPT Term_TermType = 11
	// STRING {timeout: !NUMBER} -> Function(*)
	Term_UUID Term_TermType = 169
	// Takes an HTTP URL and gets it.  If the get succeeds and
	//  returns valid JSON, it is converted into a DATUM
	Term_HTTP Term_TermType = 153
	// Takes a string and throws an error with that message.
	// Inside of a `default` block, you can omit the first
	// argument to rethrow whatever error you catch (this is most
	// useful as an argument to the `default` filter optarg).
	Term_ERROR Term_TermType = 12
	// Takes nothing and returns a reference to the implicit variable.
	Term_IMPLICIT_VAR Term_TermType = 13
	// * Data Operators
	// Returns a reference to a database.
	Term_DB Term_TermType = 14
	// Returns a reference to a table.
	Term_TABLE Term_TermType = 15
	// STRING, {read_mode:STRING, identifier_format:STRING} -> Table
	// Gets a single element from a table by its primary or a secondary key.
	Term_GET Term_TermType = 16
	// Table, STRING -> NULL            | Table, NUMBER -> NULL |
	Term_GET_ALL Term_TermType = 78
	// Simple DATUM Ops
	Term_EQ  Term_TermType = 17
	Term_NE  Term_TermType = 18
	Term_LT  Term_TermType = 19
	Term_LE  Term_TermType = 20
	Term_GT  Term_TermType = 21
	Term_GE  Term_TermType = 22
	Term_NOT Term_TermType = 23
	// ADD can either add two numbers or concatenate two arrays.
	Term_ADD   Term_TermType = 24
	Term_SUB   Term_TermType = 25
	Term_MUL   Term_TermType = 26
	Term_DIV   Term_TermType = 27
	Term_MOD   Term_TermType = 28
	Term_FLOOR Term_TermType = 183
	Term_CEIL  Term_TermType = 184
	Term_ROUND Term_TermType = 185
	// DATUM Array Ops
	// Append a single element to the end of an array (like `snoc`).
	Term_APPEND Term_TermType = 29
	// Prepend a single element to the end of an array (like `cons`).
	Term_PREPEND Term_TermType = 80
	// Remove the elements of one array from another array.
	Term_DIFFERENCE Term_TermType = 95
	// DATUM Set Ops
	// Set ops work on arrays. They don't use actual sets and thus have
	// performance characteristics you would expect from arrays rather than
	// from sets. All set operations have the post condition that they
	// array they return contains no duplicate values.
	Term_SET_INSERT       Term_TermType = 88
	Term_SET_INTERSECTION Term_TermType = 89
	Term_SET_UNION        Term_TermType = 90
	Term_SET_DIFFERENCE   Term_TermType = 91
	Term_SLICE            Term_TermType = 30
	Term_SKIP             Term_TermType = 70
	Term_LIMIT            Term_TermType = 71
	Term_OFFSETS_OF       Term_TermType = 87
	Term_CONTAINS         Term_TermType = 93
	// Stream/Object Ops
	// Get a particular field from an object, or map that over a
	// sequence.
	Term_GET_FIELD Term_TermType = 31
	// | Sequence, STRING -> Sequence
	// Return an array containing the keys of the object.
	Term_KEYS Term_TermType = 94
	// Return an array containing the values of the object.
	Term_VALUES Term_TermType = 186
	// Creates an object
	Term_OBJECT Term_TermType = 143
	// Check whether an object contains all the specified fields,
	// or filters a sequence so that all objects inside of it
	// contain all the specified fields.
	Term_HAS_FIELDS Term_TermType = 32
	// x.with_fields(...) <=> x.has_fields(...).pluck(...)
	Term_WITH_FIELDS Term_TermType = 96
	// Get a subset of an object by selecting some attributes to preserve,
	// or map that over a sequence.  (Both pick and pluck, polymorphic.)
	Term_PLUCK Term_TermType = 33
	// Get a subset of an object by selecting some attributes to discard, or
	// map that over a sequence.  (Both unpick and without, polymorphic.)
	Term_WITHOUT Term_TermType = 34
	// Merge objects (right-preferential)
	Term_MERGE Term_TermType = 35
	// Sequence Ops
	// Get all elements of a sequence between two values.
	// Half-open by default, but the openness of either side can be
	// changed by passing 'closed' or 'open for `right_bound` or
	// `left_bound`.
	Term_BETWEEN_DEPRECATED Term_TermType = 36
	// With the newer version, clients should use `r.minval` and `r.maxval` for unboundedness
	Term_BETWEEN Term_TermType = 182
	Term_REDUCE  Term_TermType = 37
	Term_MAP     Term_TermType = 38
	Term_FOLD    Term_TermType = 187
	// Filter a sequence with either a function or a shortcut
	// object (see API docs for details).  The body of FILTER is
	// wrapped in an implicit `.default(false)`, and you can
	// change the default value by specifying the `default`
	// optarg.  If you make the default `r.error`, all errors
	// caught by `default` will be rethrown as if the `default`
	// did not exist.
	Term_FILTER Term_TermType = 39
	// Sequence, OBJECT, {default:DATUM} -> Sequence
	// Map a function over a sequence and then concatenate the results together.
	Term_CONCAT_MAP Term_TermType = 40
	// Order a sequence based on one or more attributes.
	Term_ORDER_BY Term_TermType = 41
	// Get all distinct elements of a sequence (like `uniq`).
	Term_DISTINCT Term_TermType = 42
	// Count the number of elements in a sequence, or only the elements that match
	// a given filter.
	Term_COUNT    Term_TermType = 43
	Term_IS_EMPTY Term_TermType = 86
	// Take the union of multiple sequences (preserves duplicate elements! (use distinct)).
	Term_UNION Term_TermType = 44
	// Get the Nth element of a sequence.
	Term_NTH Term_TermType = 45
	// do NTH or GET_FIELD depending on target object
	Term_BRACKET    Term_TermType = 170
	Term_INNER_JOIN Term_TermType = 48
	Term_OUTER_JOIN Term_TermType = 49
	// An inner-join that does an equality comparison on two attributes.
	Term_EQ_JOIN Term_TermType = 50
	Term_ZIP     Term_TermType = 72
	Term_RANGE   Term_TermType = 173
	// Array Ops
	// Insert an element in to an array at a given index.
	Term_INSERT_AT Term_TermType = 82
	// Remove an element at a given index from an array.
	Term_DELETE_AT Term_TermType = 83
	// ARRAY, NUMBER, NUMBER -> ARRAY
	// Change the element at a given index of an array.
	Term_CHANGE_AT Term_TermType = 84
	// Splice one array in to another array.
	Term_SPLICE_AT Term_TermType = 85
	// * Type Ops
	// Coerces a datum to a named type (e.g. "bool").
	// If you previously used `stream_to_array`, you should use this instead
	// with the type "array".
	Term_COERCE_TO Term_TermType = 51
	// Returns the named type of a datum (e.g. TYPE_OF(true) = "BOOL")
	Term_TYPE_OF Term_TermType = 52
	// * Write Ops (the OBJECTs contain data about number of errors etc.)
	// Updates all the rows in a selection.  Calls its Function with the row
	// to be updated, and then merges the result of that call.
	Term_UPDATE Term_TermType = 53
	// SingleSelection, Function(1), {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT |
	// StreamSelection, OBJECT,      {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT |
	// SingleSelection, OBJECT,      {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT
	// Deletes all the rows in a selection.
	Term_DELETE Term_TermType = 54
	// Replaces all the rows in a selection.  Calls its Function with the row
	// to be replaced, and then discards it and stores the result of that
	// call.
	Term_REPLACE Term_TermType = 55
	// Inserts into a table.  If `conflict` is replace, overwrites
	// entries with the same primary key.  If `conflict` is
	// update, does an update on the entry.  If `conflict` is
	// error, or is omitted, conflicts will trigger an error.
	Term_INSERT Term_TermType = 56
	// * Administrative OPs
	// Creates a database with a particular name.
	Term_DB_CREATE Term_TermType = 57
	// Drops a database with a particular name.
	Term_DB_DROP Term_TermType = 58
	// Lists all the databases by name.  (Takes no arguments)
	Term_DB_LIST Term_TermType = 59
	// Creates a table with a particular name in a particular
	// database.  (You may omit the first argument to use the
	// default database.)
	Term_TABLE_CREATE Term_TermType = 60
	// Database, STRING, {primary_key:STRING, shards:NUMBER, replicas:OBJECT, primary_replica_tag:STRING} -> OBJECT
	// STRING, {primary_key:STRING, shards:NUMBER, replicas:NUMBER, primary_replica_tag:STRING} -> OBJECT
	// STRING, {primary_key:STRING, shards:NUMBER, replicas:OBJECT, primary_replica_tag:STRING} -> OBJECT
	// Drops a table with a particular name from a particular
	// database.  (You may omit the first argument to use the
	// default database.)
	Term_TABLE_DROP Term_TermType = 61
	// STRING -> OBJECT
	// Lists all the tables in a particular database.  (You may
	// omit the first argument to use the default database.)
	Term_TABLE_LIST Term_TermType = 62
	//  -> ARRAY
	// Returns the row in the `rethinkdb.table_config` or `rethinkdb.db_config` table
	// that corresponds to the given database or table.
	Term_CONFIG Term_TermType = 174
	// Table -> SingleSelection
	// Returns the row in the `rethinkdb.table_status` table that corresponds to the
	// given table.
	Term_STATUS Term_TermType = 175
	// Called on a table, waits for that table to be ready for read/write operations.
	// Called on a database, waits for all of the tables in the database to be ready.
	// Returns the corresponding row or rows from the `rethinkdb.table_status` table.
	Term_WAIT Term_TermType = 177
	// Database -> OBJECT
	// Generates a new config for the given table, or all tables in the given database
	// The `shards` and `replicas` arguments are required. If `emergency_repair` is
	// specified, it will enter a completely different mode of repairing a table
	// which has lost half or more of its replicas.
	Term_RECONFIGURE Term_TermType = 176
	//                  dry_run:BOOLEAN]
	//                 } -> OBJECT
	// Database|Table, {shards:NUMBER, replicas:OBJECT [,
	//                  primary_replica_tag:STRING,
	//                  nonvoting_replica_tags:ARRAY,
	//                  dry_run:BOOLEAN]
	//                 } -> OBJECT
	// Table, {emergency_repair:STRING, dry_run:BOOLEAN} -> OBJECT
	// Balances the table's shards but leaves everything else the same. Can also be
	// applied to an entire database at once.
	Term_REBALANCE Term_TermType = 179
	// Ensures that previously issued soft-durability writes are complete and
	// written to disk.
	Term_SYNC Term_TermType = 138
	// Set global, database, or table-specific permissions
	Term_GRANT Term_TermType = 188
	// * Secondary indexes OPs
	// Creates a new secondary index with a particular name and definition.
	Term_INDEX_CREATE Term_TermType = 75
	// Drops a secondary index with a particular name from the specified table.
	Term_INDEX_DROP Term_TermType = 76
	// Lists all secondary indexes on a particular table.
	Term_INDEX_LIST Term_TermType = 77
	// Gets information about whether or not a set of indexes are ready to
	// be accessed. Returns a list of objects that look like this:
	// {index:STRING, ready:BOOL[, progress:NUMBER]}
	Term_INDEX_STATUS Term_TermType = 139
	// Blocks until a set of indexes are ready to be accessed. Returns the
	// same values INDEX_STATUS.
	Term_INDEX_WAIT Term_TermType = 140
	// Renames the given index to a new name
	Term_INDEX_RENAME Term_TermType = 156
	// * Write hook Function OPs
	// Creates a new write hook function with a particular definition
	Term_SET_WRITE_HOOK Term_TermType = 189
	// Gets an existing write hook function on a table
	Term_GET_WRITE_HOOK Term_TermType = 190
	// * Control Operators
	// Calls a function on data
	Term_FUNCALL Term_TermType = 64
	// Executes its first argument, and returns its second argument if it
	// got [true] or its third argument if it got [false] (like an `if`
	// statement).
	Term_BRANCH Term_TermType = 65
	// Returns true if any of its arguments returns true (short-circuits).
	Term_OR Term_TermType = 66
	// Returns true if all of its arguments return true (short-circuits).
	Term_AND Term_TermType = 67
	// Calls its Function with each entry in the sequence
	// and executes the array of terms that Function returns.
	Term_FOR_EACH Term_TermType = 68
	// An anonymous function.  Takes an array of numbers representing
	// variables (see [VAR] above), and a [Term] to execute with those in
	// scope.  Returns a function that may be passed an array of arguments,
	// then executes the Term with those bound to the variable names.  The
	// user will never construct this directly.  We use it internally for
	// things like `map` which take a function.  The "arity" of a [Function] is
	// the number of arguments it takes.
	// For example, here's what `_X_.map{|x| x+2}` turns into:
	// Term {
	//   type = MAP;
	//   args = [_X_,
	//           Term {
	//             type = Function;
	//             args = [Term {
	//                       type = DATUM;
	//                       datum = Datum {
	//                         type = R_ARRAY;
	//                         r_array = [Datum { type = R_NUM; r_num = 1; }];
	//                       };
	//                     },
	//                     Term {
	//                       type = ADD;
	//                       args = [Term {
	//                                 type = VAR;
	//                                 args = [Term {
	//                                           type = DATUM;
	//                                           datum = Datum { type = R_NUM;
	//                                                           r_num = 1};
	//                                         }];
	//                               },
	//                               Term {
	//                                 type = DATUM;
	//                                 datum = Datum { type = R_NUM; r_num = 2; };
	//                               }];
	//                     }];
	//           }];
	Term_FUNC Term_TermType = 69
	// Indicates to ORDER_BY that this attribute is to be sorted in ascending order.
	Term_ASC Term_TermType = 73
	// Indicates to ORDER_BY that this attribute is to be sorted in descending order.
	Term_DESC Term_TermType = 74
	// Gets info about anything.  INFO is most commonly called on tables.
	Term_INFO Term_TermType = 79
	// `a.match(b)` returns a match object if the string `a`
	// matches the regular expression `b`.
	Term_MATCH Term_TermType = 97
	// Change the case of a string.
	Term_UPCASE   Term_TermType = 141
	Term_DOWNCASE Term_TermType = 142
	// Select a number of elements from sequence with uniform distribution.
	Term_SAMPLE Term_TermType = 81
	// Evaluates its first argument.  If that argument returns
	// NULL or throws an error related to the absence of an
	// expected value (for instance, accessing a non-existent
	// field or adding NULL to an integer), DEFAULT will either
	// return its second argument or execute it if it's a
	// function.  If the second argument is a function, it will be
	// passed either the text of the error or NULL as its
	// argument.
	Term_DEFAULT Term_TermType = 92
	// Parses its first argument as a json string and returns it as a
	// datum.
	Term_JSON Term_TermType = 98
	// Parses its first arguments as an ISO 8601 time and returns it as a
	// datum.
	Term_ISO8601 Term_TermType = 99
	// Prints a time as an ISO 8601 time.
	Term_TO_ISO8601 Term_TermType = 100
	// Returns a time given seconds since epoch in UTC.
	Term_EPOCH_TIME Term_TermType = 101
	// Returns seconds since epoch in UTC given a time.
	Term_TO_EPOCH_TIME Term_TermType = 102
	// The time the query was received by the server.
	Term_NOW Term_TermType = 103
	// Puts a time into an ISO 8601 timezone.
	Term_IN_TIMEZONE Term_TermType = 104
	// a.during(b, c) returns whether a is in the range [b, c)
	Term_DURING Term_TermType = 105
	// Retrieves the date portion of a time.
	Term_DATE Term_TermType = 106
	// x.time_of_day == x.date - x
	Term_TIME_OF_DAY Term_TermType = 126
	// Returns the timezone of a time.
	Term_TIMEZONE Term_TermType = 127
	// These access the various components of a time.
	Term_YEAR        Term_TermType = 128
	Term_MONTH       Term_TermType = 129
	Term_DAY         Term_TermType = 130
	Term_DAY_OF_WEEK Term_TermType = 131
	Term_DAY_OF_YEAR Term_TermType = 132
	Term_HOURS       Term_TermType = 133
	Term_MINUTES     Term_TermType = 134
	Term_SECONDS     Term_TermType = 135
	// Construct a time from a date and optional timezone or a
	// date+time and optional timezone.
	Term_TIME Term_TermType = 136
	// Constants for ISO 8601 days of the week.
	Term_MONDAY    Term_TermType = 107
	Term_TUESDAY   Term_TermType = 108
	Term_WEDNESDAY Term_TermType = 109
	Term_THURSDAY  Term_TermType = 110
	Term_FRIDAY    Term_TermType = 111
	Term_SATURDAY  Term_TermType = 112
	Term_SUNDAY    Term_TermType = 113
	// Constants for ISO 8601 months.
	Term_JANUARY   Term_TermType = 114
	Term_FEBRUARY  Term_TermType = 115
	Term_MARCH     Term_TermType = 116
	Term_APRIL     Term_TermType = 117
	Term_MAY       Term_TermType = 118
	Term_JUNE      Term_TermType = 119
	Term_JULY      Term_TermType = 120
	Term_AUGUST    Term_TermType = 121
	Term_SEPTEMBER Term_TermType = 122
	Term_OCTOBER   Term_TermType = 123
	Term_NOVEMBER  Term_TermType = 124
	Term_DECEMBER  Term_TermType = 125
	// Indicates to MERGE to replace, or remove in case of an empty literal, the
	// other object rather than merge it.
	Term_LITERAL Term_TermType = 137
	// SEQUENCE, STRING -> GROUPED_SEQUENCE | SEQUENCE, FUNCTION -> GROUPED_SEQUENCE
	Term_GROUP Term_TermType = 144
	Term_SUM   Term_TermType = 145
	Term_AVG   Term_TermType = 146
	Term_MIN   Term_TermType = 147
	Term_MAX   Term_TermType = 148
	// `str.split()` splits on whitespace
	// `str.split(" ")` splits on spaces only
	// `str.split(" ", 5)` splits on spaces with at most 5 results
	// `str.split(nil, 5)` splits on whitespace with at most 5 results
	Term_SPLIT   Term_TermType = 149
	Term_UNGROUP Term_TermType = 150
	// Takes a range of numbers and returns a random number within the range
	Term_RANDOM  Term_TermType = 151
	Term_CHANGES Term_TermType = 152
	Term_ARGS    Term_TermType = 154
	// BINARY is client-only at the moment, it is not supported on the server
	Term_BINARY           Term_TermType = 155
	Term_GEOJSON          Term_TermType = 157
	Term_TO_GEOJSON       Term_TermType = 158
	Term_POINT            Term_TermType = 159
	Term_LINE             Term_TermType = 160
	Term_POLYGON          Term_TermType = 161
	Term_DISTANCE         Term_TermType = 162
	Term_INTERSECTS       Term_TermType = 163
	Term_INCLUDES         Term_TermType = 164
	Term_CIRCLE           Term_TermType = 165
	Term_GET_INTERSECTING Term_TermType = 166
	Term_FILL             Term_TermType = 167
	Term_GET_NEAREST      Term_TermType = 168
	Term_POLYGON_SUB      Term_TermType = 171
	// Returns the datum as a JSON string.
	// N.B.: we would really prefer this be named TO_JSON and that exists as
	// an alias in Python and JavaScript drivers; however it conflicts with the
	// standard `to_json` method defined by Ruby's standard json library.
	Term_TO_JSON_STRING Term_TermType = 172
	// Constants for specifying key ranges
	Term_MINVAL Term_TermType = 180
	Term_MAXVAL Term_TermType = 181
	// Bitwise operations
	Term_BIT_AND Term_TermType = 191
	Term_BIT_OR  Term_TermType = 192
	Term_BIT_XOR Term_TermType = 193
	Term_BIT_NOT Term_TermType = 194
	Term_BIT_SAL Term_TermType = 195
	Term_BIT_SAR Term_TermType = 196
)

var Term_TermType_name = map[int32]string{
	1:   "DATUM",
	2:   "MAKE_ARRAY",
	3:   "MAKE_OBJ",
	10:  "VAR",
	11:  "JAVASCRIPT",
	169: "UUID",
	153: "HTTP",
	12:  "ERROR",
	13:  "IMPLICIT_VAR",
	14:  "DB",
	15:  "TABLE",
	16:  "GET",
	78:  "GET_ALL",
	17:  "EQ",
	18:  "NE",
	19:  "LT",
	20:  "LE",
	21:  "GT",
	22:  "GE",
	23:  "NOT",
	24:  "ADD",
	25:  "SUB",
	26:  "MUL",
	27:  "DIV",
	28:  "MOD",
	183: "FLOOR",
	184: "CEIL",
	185: "ROUND",
	29:  "APPEND",
	80:  "PREPEND",
	95:  "DIFFERENCE",
	88:  "SET_INSERT",
	89:  "SET_INTERSECTION",
	90:  "SET_UNION",
	91:  "SET_DIFFERENCE",
	30:  "SLICE",
	70:  "SKIP",
	71:  "LIMIT",
	87:  "OFFSETS_OF",
	93:  "CONTAINS",
	31:  "GET_FIELD",
	94:  "KEYS",
	186: "VALUES",
	143: "OBJECT",
	32:  "HAS_FIELDS",
	96:  "WITH_FIELDS",
	33:  "PLUCK",
	34:  "WITHOUT",
	35:  "MERGE",
	36:  "BETWEEN_DEPRECATED",
	182: "BETWEEN",
	37:  "REDUCE",
	38:  "MAP",
	187: "FOLD",
	39:  "FILTER",
	40:  "CONCAT_MAP",
	41:  "ORDER_BY",
	42:  "DISTINCT",
	43:  "COUNT",
	86:  "IS_EMPTY",
	44:  "UNION",
	45:  "NTH",
	170: "BRACKET",
	48:  "INNER_JOIN",
	49:  "OUTER_JOIN",
	50:  "EQ_JOIN",
	72:  "ZIP",
	173: "RANGE",
	82:  "INSERT_AT",
	83:  "DELETE_AT",
	84:  "CHANGE_AT",
	85:  "SPLICE_AT",
	51:  "COERCE_TO",
	52:  "TYPE_OF",
	53:  "UPDATE",
	54:  "DELETE",
	55:  "REPLACE",
	56:  "INSERT",
	57:  "DB_CREATE",
	58:  "DB_DROP",
	59:  "DB_LIST",
	60:  "TABLE_CREATE",
	61:  "TABLE_DROP",
	62:  "TABLE_LIST",
	174: "CONFIG",
	175: "STATUS",
	177: "WAIT",
	176: "RECONFIGURE",
	179: "REBALANCE",
	138: "SYNC",
	188: "GRANT",
	75:  "INDEX_CREATE",
	76:  "INDEX_DROP",
	77:  "INDEX_LIST",
	139: "INDEX_STATUS",
	140: "INDEX_WAIT",
	156: "INDEX_RENAME",
	189: "SET_WRITE_HOOK",
	190: "GET_WRITE_HOOK",
	64:  "FUNCALL",
	65:  "BRANCH",
	66:  "OR",
	67:  "AND",
	68:  "FOR_EACH",
	69:  "FUNC",
	73:  "ASC",
	74:  "DESC",
	79:  "INFO",
	97:  "MATCH",
	141: "UPCASE",
	142: "DOWNCASE",
	81:  "SAMPLE",
	92:  "DEFAULT",
	98:  "JSON",
	99:  "ISO8601",
	100: "TO_ISO8601",
	101: "EPOCH_TIME",
	102: "TO_EPOCH_TIME",
	103: "NOW",
	104: "IN_TIMEZONE",
	105: "DURING",
	106: "DATE",
	126: "TIME_OF_DAY",
	127: "TIMEZONE",
	128: "YEAR",
	129: "MONTH",
	130: "DAY",
	131: "DAY_OF_WEEK",
	132: "DAY_OF_YEAR",
	133: "HOURS",
	134: "MINUTES",
	135: "SECONDS",
	136: "TIME",
	107: "MONDAY",
	108: "TUESDAY",
	109: "WEDNESDAY",
	110: "THURSDAY",
	111: "FRIDAY",
	112: "SATURDAY",
	113: "SUNDAY",
	114: "JANUARY",
	115: "FEBRUARY",
	116: "MARCH",
	117: "APRIL",
	118: "MAY",
	119: "JUNE",
	120: "JULY",
	121: "AUGUST",
	122: "SEPTEMBER",
	123: "OCTOBER",
	124: "NOVEMBER",
	125: "DECEMBER",
	137: "LITERAL",
	144: "GROUP",
	145: "SUM",
	146: "AVG",
	147: "MIN",
	148: "MAX",
	149: "SPLIT",
	150: "UNGROUP",
	151: "RANDOM",
	152: "CHANGES",
	154: "ARGS",
	155: "BINARY",
	157: "GEOJSON",
	158: "TO_GEOJSON",
	159: "POINT",
	160: "LINE",
	161: "POLYGON",
	162: "DISTANCE",
	163: "INTERSECTS",
	164: "INCLUDES",
	165: "CIRCLE",
	166: "GET_INTERSECTING",
	167: "FILL",
	168: "GET_NEAREST",
	171: "POLYGON_SUB",
	172: "TO_JSON_STRING",
	180: "MINVAL",
	181: "MAXVAL",
	191: "BIT_AND",
	192: "BIT_OR",
	193: "BIT_XOR",
	194: "BIT_NOT",
	195: "BIT_SAL",
	196: "BIT_SAR",
}
var Term_TermType_value = map[string]int32{
	"DATUM":              1,
	"MAKE_ARRAY":         2,
	"MAKE_OBJ":           3,
	"VAR":                10,
	"JAVASCRIPT":         11,
	"UUID":               169,
	"HTTP":               153,
	"ERROR":              12,
	"IMPLICIT_VAR":       13,
	"DB":                 14,
	"TABLE":              15,
	"GET":                16,
	"GET_ALL":            78,
	"EQ":                 17,
	"NE":                 18,
	"LT":                 19,
	"LE":                 20,
	"GT":                 21,
	"GE":                 22,
	"NOT":                23,
	"ADD":                24,
	"SUB":                25,
	"MUL":                26,
	"DIV":                27,
	"MOD":                28,
	"FLOOR":              183,
	"CEIL":               184,
	"ROUND":              185,
	"APPEND":             29,
	"PREPEND":            80,
	"DIFFERENCE":         95,
	"SET_INSERT":         88,
	"SET_INTERSECTION":   89,
	"SET_UNION":          90,
	"SET_DIFFERENCE":     91,
	"SLICE":              30,
	"SKIP":               70,
	"LIMIT":              71,
	"OFFSETS_OF":         87,
	"CONTAINS":           93,
	"GET_FIELD":          31,
	"KEYS":               94,
	"VALUES":             186,
	"OBJECT":             143,
	"HAS_FIELDS":         32,
	"WITH_FIELDS":        96,
	"PLUCK":              33,
	"WITHOUT":            34,
	"MERGE":              35,
	"BETWEEN_DEPRECATED": 36,
	"BETWEEN":            182,
	"REDUCE":             37,
	"MAP":                38,
	"FOLD":               187,
	"FILTER":             39,
	"CONCAT_MAP":         40,
	"ORDER_BY":           41,
	"DISTINCT":           42,
	"COUNT":              43,
	"IS_EMPTY":           86,
	"UNION":              44,
	"NTH":                45,
	"BRACKET":            170,
	"INNER_JOIN":         48,
	"OUTER_JOIN":         49,
	"EQ_JOIN":            50,
	"ZIP":                72,
	"RANGE":              173,
	"INSERT_AT":          82,
	"DELETE_AT":          83,
	"CHANGE_AT":          84,
	"SPLICE_AT":          85,
	"COERCE_TO":          51,
	"TYPE_OF":            52,
	"UPDATE":             53,
	"DELETE":             54,
	"REPLACE":            55,
	"INSERT":             56,
	"DB_CREATE":          57,
	"DB_DROP":            58,
	"DB_LIST":            59,
	"TABLE_CREATE":       60,
	"TABLE_DROP":         61,
	"TABLE_LIST":         62,
	"CONFIG":             174,
	"STATUS":             175,
	"WAIT":               177,
	"RECONFIGURE":        176,
	"REBALANCE":          179,
	"SYNC":               138,
	"GRANT":              188,
	"INDEX_CREATE":       75,
	"INDEX_DROP":         76,
	"INDEX_LIST":         77,
	"INDEX_STATUS":       139,
	"INDEX_WAIT":         140,
	"INDEX_RENAME":       156,
	"SET_WRITE_HOOK":     189,
	"GET_WRITE_HOOK":     190,
	"FUNCALL":            64,
	"BRANCH":             65,
	"OR":                 66,
	"AND":                67,
	"FOR_EACH":           68,
	"FUNC":               69,
	"ASC":                73,
	"DESC":               74,
	"INFO":               79,
	"MATCH":              97,
	"UPCASE":             141,
	"DOWNCASE":           142,
	"SAMPLE":             81,
	"DEFAULT":            92,
	"JSON":               98,
	"ISO8601":            99,
	"TO_ISO8601":         100,
	"EPOCH_TIME":         101,
	"TO_EPOCH_TIME":      102,
	"NOW":                103,
	"IN_TIMEZONE":        104,
	"DURING":             105,
	"DATE":               106,
	"TIME_OF_DAY":        126,
	"TIMEZONE":           127,
	"YEAR":               128,
	"MONTH":              129,
	"DAY":                130,
	"DAY_OF_WEEK":        131,
	"DAY_OF_YEAR":        132,
	"HOURS":              133,
	"MINUTES":            134,
	"SECONDS":            135,
	"TIME":               136,
	"MONDAY":             107,
	"TUESDAY":            108,
	"WEDNESDAY":          109,
	"THURSDAY":           110,
	"FRIDAY":             111,
	"SATURDAY":           112,
	"SUNDAY":             113,
	"JANUARY":            114,
	"FEBRUARY":           115,
	"MARCH":              116,
	"APRIL":              117,
	"MAY":                118,
	"JUNE":               119,
	"JULY":               120,
	"AUGUST":             121,
	"SEPTEMBER":          122,
	"OCTOBER":            123,
	"NOVEMBER":           124,
	"DECEMBER":           125,
	"LITERAL":            137,
	"GROUP":              144,
	"SUM":                145,
	"AVG":                146,
	"MIN":                147,
	"MAX":                148,
	"SPLIT":              149,
	"UNGROUP":            150,
	"RANDOM":             151,
	"CHANGES":            152,
	"ARGS":               154,
	"BINARY":             155,
	"GEOJSON":            157,
	"TO_GEOJSON":         158,
	"POINT":              159,
	"LINE":               160,
	"POLYGON":            161,
	"DISTANCE":           162,
	"INTERSECTS":         163,
	"INCLUDES":           164,
	"CIRCLE":             165,
	"GET_INTERSECTING":   166,
	"FILL":               167,
	"GET_NEAREST":        168,
	"POLYGON_SUB":        171,
	"TO_JSON_STRING":     172,
	"MINVAL":             180,
	"MAXVAL":             181,
	"BIT_AND":            191,
	"BIT_OR":             192,
	"BIT_XOR":            193,
	"BIT_NOT":            194,
	"BIT_SAL":            195,
	"BIT_SAR":            196,
}

func (x Term_TermType) Enum() *Term_TermType {
	p := new(Term_TermType)
	*p = x
	return p
}
func (x Term_TermType) String() string {
	return proto.EnumName(Term_TermType_name, int32(x))
}
func (x *Term_TermType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Term_TermType_value, data, "Term_TermType")
	if err != nil {
		return err
	}
	*x = Term_TermType(value)
	return nil
}
func (Term_TermType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{6, 0}
}

type VersionDummy struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionDummy) Reset()         { *m = VersionDummy{} }
func (m *VersionDummy) String() string { return proto.CompactTextString(m) }
func (*VersionDummy) ProtoMessage()    {}
func (*VersionDummy) Descriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{0}
}
func (m *VersionDummy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VersionDummy.Unmarshal(m, b)
}
func (m *VersionDummy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VersionDummy.Marshal(b, m, deterministic)
}
func (dst *VersionDummy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionDummy.Merge(dst, src)
}
func (m *VersionDummy) XXX_Size() int {
	return xxx_messageInfo_VersionDummy.Size(m)
}
func (m *VersionDummy) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionDummy.DiscardUnknown(m)
}

var xxx_messageInfo_VersionDummy proto.InternalMessageInfo

// You send one of:
// * A [START] query with a [Term] to evaluate and a unique-per-connection token.
// * A [CONTINUE] query with the same token as a [START] query that returned
//   [SUCCESS_PARTIAL] in its [Response].
// * A [STOP] query with the same token as a [START] query that you want to stop.
// * A [NOREPLY_WAIT] query with a unique per-connection token. The server answers
//   with a [WAIT_COMPLETE] [Response].
// * A [SERVER_INFO] query. The server answers with a [SERVER_INFO] [Response].
type Query struct {
	Type *Query_QueryType `protobuf:"varint,1,opt,name=type,enum=Query_QueryType" json:"type,omitempty"`
	// A [Term] is how we represent the operations we want a query to perform.
	Query *Term  `protobuf:"bytes,2,opt,name=query" json:"query,omitempty"`
	Token *int64 `protobuf:"varint,3,opt,name=token" json:"token,omitempty"`
	// This flag is ignored on the server.  `noreply` should be added
	// to `global_optargs` instead (the key "noreply" should map to
	// either true or false).
	OBSOLETENoreply *bool `protobuf:"varint,4,opt,name=OBSOLETE_noreply,json=OBSOLETENoreply,def=0" json:"OBSOLETE_noreply,omitempty"`
	// If this is set to [true], then [Datum] values will sometimes be
	// of [DatumType] [R_JSON] (see below).  This can provide enormous
	// speedups in languages with poor protobuf libraries.
	AcceptsRJson         *bool              `protobuf:"varint,5,opt,name=accepts_r_json,json=acceptsRJson,def=0" json:"accepts_r_json,omitempty"`
	GlobalOptargs        []*Query_AssocPair `protobuf:"bytes,6,rep,name=global_optargs,json=globalOptargs" json:"global_optargs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{1}
}
func (m *Query) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Query.Unmarshal(m, b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Query.Marshal(b, m, deterministic)
}
func (dst *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(dst, src)
}
func (m *Query) XXX_Size() int {
	return xxx_messageInfo_Query.Size(m)
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

const Default_Query_OBSOLETENoreply bool = false
const Default_Query_AcceptsRJson bool = false

func (m *Query) GetType() Query_QueryType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Query_START
}

func (m *Query) GetQuery() *Term {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *Query) GetToken() int64 {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return 0
}

func (m *Query) GetOBSOLETENoreply() bool {
	if m != nil && m.OBSOLETENoreply != nil {
		return *m.OBSOLETENoreply
	}
	return Default_Query_OBSOLETENoreply
}

func (m *Query) GetAcceptsRJson() bool {
	if m != nil && m.AcceptsRJson != nil {
		return *m.AcceptsRJson
	}
	return Default_Query_AcceptsRJson
}

func (m *Query) GetGlobalOptargs() []*Query_AssocPair {
	if m != nil {
		return m.GlobalOptargs
	}
	return nil
}

type Query_AssocPair struct {
	Key                  *string  `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Val                  *Term    `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Query_AssocPair) Reset()         { *m = Query_AssocPair{} }
func (m *Query_AssocPair) String() string { return proto.CompactTextString(m) }
func (*Query_AssocPair) ProtoMessage()    {}
func (*Query_AssocPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{1, 0}
}
func (m *Query_AssocPair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Query_AssocPair.Unmarshal(m, b)
}
func (m *Query_AssocPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Query_AssocPair.Marshal(b, m, deterministic)
}
func (dst *Query_AssocPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query_AssocPair.Merge(dst, src)
}
func (m *Query_AssocPair) XXX_Size() int {
	return xxx_messageInfo_Query_AssocPair.Size(m)
}
func (m *Query_AssocPair) XXX_DiscardUnknown() {
	xxx_messageInfo_Query_AssocPair.DiscardUnknown(m)
}

var xxx_messageInfo_Query_AssocPair proto.InternalMessageInfo

func (m *Query_AssocPair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Query_AssocPair) GetVal() *Term {
	if m != nil {
		return m.Val
	}
	return nil
}

// A backtrace frame (see `backtrace` in Response below)
type Frame struct {
	Type                 *Frame_FrameType `protobuf:"varint,1,opt,name=type,enum=Frame_FrameType" json:"type,omitempty"`
	Pos                  *int64           `protobuf:"varint,2,opt,name=pos" json:"pos,omitempty"`
	Opt                  *string          `protobuf:"bytes,3,opt,name=opt" json:"opt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Frame) Reset()         { *m = Frame{} }
func (m *Frame) String() string { return proto.CompactTextString(m) }
func (*Frame) ProtoMessage()    {}
func (*Frame) Descriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{2}
}
func (m *Frame) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Frame.Unmarshal(m, b)
}
func (m *Frame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Frame.Marshal(b, m, deterministic)
}
func (dst *Frame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Frame.Merge(dst, src)
}
func (m *Frame) XXX_Size() int {
	return xxx_messageInfo_Frame.Size(m)
}
func (m *Frame) XXX_DiscardUnknown() {
	xxx_messageInfo_Frame.DiscardUnknown(m)
}

var xxx_messageInfo_Frame proto.InternalMessageInfo

func (m *Frame) GetType() Frame_FrameType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Frame_POS
}

func (m *Frame) GetPos() int64 {
	if m != nil && m.Pos != nil {
		return *m.Pos
	}
	return 0
}

func (m *Frame) GetOpt() string {
	if m != nil && m.Opt != nil {
		return *m.Opt
	}
	return ""
}

type Backtrace struct {
	Frames               []*Frame `protobuf:"bytes,1,rep,name=frames" json:"frames,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Backtrace) Reset()         { *m = Backtrace{} }
func (m *Backtrace) String() string { return proto.CompactTextString(m) }
func (*Backtrace) ProtoMessage()    {}
func (*Backtrace) Descriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{3}
}
func (m *Backtrace) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Backtrace.Unmarshal(m, b)
}
func (m *Backtrace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Backtrace.Marshal(b, m, deterministic)
}
func (dst *Backtrace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Backtrace.Merge(dst, src)
}
func (m *Backtrace) XXX_Size() int {
	return xxx_messageInfo_Backtrace.Size(m)
}
func (m *Backtrace) XXX_DiscardUnknown() {
	xxx_messageInfo_Backtrace.DiscardUnknown(m)
}

var xxx_messageInfo_Backtrace proto.InternalMessageInfo

func (m *Backtrace) GetFrames() []*Frame {
	if m != nil {
		return m.Frames
	}
	return nil
}

// You get back a response with the same [token] as your query.
type Response struct {
	Type      *Response_ResponseType  `protobuf:"varint,1,opt,name=type,enum=Response_ResponseType" json:"type,omitempty"`
	ErrorType *Response_ErrorType     `protobuf:"varint,7,opt,name=error_type,json=errorType,enum=Response_ErrorType" json:"error_type,omitempty"`
	Notes     []Response_ResponseNote `protobuf:"varint,6,rep,name=notes,enum=Response_ResponseNote" json:"notes,omitempty"`
	Token     *int64                  `protobuf:"varint,2,opt,name=token" json:"token,omitempty"`
	// [response] contains 1 RQL datum if [type] is [SUCCESS_ATOM] or
	// [SERVER_INFO].  [response] contains many RQL data if [type] is
	// [SUCCESS_SEQUENCE] or [SUCCESS_PARTIAL].  [response] contains 1
	// error message (of type [R_STR]) in all other cases.
	Response []*Datum `protobuf:"bytes,3,rep,name=response" json:"response,omitempty"`
	// If [type] is [CLIENT_ERROR], [TYPE_ERROR], or [RUNTIME_ERROR], then a
	// backtrace will be provided.  The backtrace says where in the query the
	// error occurred.  Ideally this information will be presented to the user as
	// a pretty-printed version of their query with the erroneous section
	// underlined.  A backtrace is a series of 0 or more [Frame]s, each of which
	// specifies either the index of a positional argument or the name of an
	// optional argument.  (Those words will make more sense if you look at the
	// [Term] message below.)
	Backtrace *Backtrace `protobuf:"bytes,4,opt,name=backtrace" json:"backtrace,omitempty"`
	// If the [global_optargs] in the [Query] that this [Response] is a
	// response to contains a key "profile" which maps to a static value of
	// true then [profile] will contain a [Datum] which provides profiling
	// information about the execution of the query. This field should be
	// returned to the user along with the result that would normally be
	// returned (a datum or a cursor). In official drivers this is accomplished
	// by putting them inside of an object with "value" mapping to the return
	// value and "profile" mapping to the profile object.
	Profile              *Datum   `protobuf:"bytes,5,opt,name=profile" json:"profile,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{4}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Response.Unmarshal(m, b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Response.Marshal(b, m, deterministic)
}
func (dst *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(dst, src)
}
func (m *Response) XXX_Size() int {
	return xxx_messageInfo_Response.Size(m)
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetType() Response_ResponseType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Response_SUCCESS_ATOM
}

func (m *Response) GetErrorType() Response_ErrorType {
	if m != nil && m.ErrorType != nil {
		return *m.ErrorType
	}
	return Response_INTERNAL
}

func (m *Response) GetNotes() []Response_ResponseNote {
	if m != nil {
		return m.Notes
	}
	return nil
}

func (m *Response) GetToken() int64 {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return 0
}

func (m *Response) GetResponse() []*Datum {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *Response) GetBacktrace() *Backtrace {
	if m != nil {
		return m.Backtrace
	}
	return nil
}

func (m *Response) GetProfile() *Datum {
	if m != nil {
		return m.Profile
	}
	return nil
}

// A [Datum] is a chunk of data that can be serialized to disk or returned to
// the user in a Response.  Currently we only support JSON types, but we may
// support other types in the future (e.g., a date type or an integer type).
type Datum struct {
	Type                 *Datum_DatumType   `protobuf:"varint,1,opt,name=type,enum=Datum_DatumType" json:"type,omitempty"`
	RBool                *bool              `protobuf:"varint,2,opt,name=r_bool,json=rBool" json:"r_bool,omitempty"`
	RNum                 *float64           `protobuf:"fixed64,3,opt,name=r_num,json=rNum" json:"r_num,omitempty"`
	RStr                 *string            `protobuf:"bytes,4,opt,name=r_str,json=rStr" json:"r_str,omitempty"`
	RArray               []*Datum           `protobuf:"bytes,5,rep,name=r_array,json=rArray" json:"r_array,omitempty"`
	RObject              []*Datum_AssocPair `protobuf:"bytes,6,rep,name=r_object,json=rObject" json:"r_object,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Datum) Reset()         { *m = Datum{} }
func (m *Datum) String() string { return proto.CompactTextString(m) }
func (*Datum) ProtoMessage()    {}
func (*Datum) Descriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{5}
}
func (m *Datum) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Datum.Unmarshal(m, b)
}
func (m *Datum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Datum.Marshal(b, m, deterministic)
}
func (dst *Datum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Datum.Merge(dst, src)
}
func (m *Datum) XXX_Size() int {
	return xxx_messageInfo_Datum.Size(m)
}
func (m *Datum) XXX_DiscardUnknown() {
	xxx_messageInfo_Datum.DiscardUnknown(m)
}

var xxx_messageInfo_Datum proto.InternalMessageInfo

func (m *Datum) GetType() Datum_DatumType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Datum_R_NULL
}

func (m *Datum) GetRBool() bool {
	if m != nil && m.RBool != nil {
		return *m.RBool
	}
	return false
}

func (m *Datum) GetRNum() float64 {
	if m != nil && m.RNum != nil {
		return *m.RNum
	}
	return 0
}

func (m *Datum) GetRStr() string {
	if m != nil && m.RStr != nil {
		return *m.RStr
	}
	return ""
}

func (m *Datum) GetRArray() []*Datum {
	if m != nil {
		return m.RArray
	}
	return nil
}

func (m *Datum) GetRObject() []*Datum_AssocPair {
	if m != nil {
		return m.RObject
	}
	return nil
}

type Datum_AssocPair struct {
	Key                  *string  `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Val                  *Datum   `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Datum_AssocPair) Reset()         { *m = Datum_AssocPair{} }
func (m *Datum_AssocPair) String() string { return proto.CompactTextString(m) }
func (*Datum_AssocPair) ProtoMessage()    {}
func (*Datum_AssocPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{5, 0}
}
func (m *Datum_AssocPair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Datum_AssocPair.Unmarshal(m, b)
}
func (m *Datum_AssocPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Datum_AssocPair.Marshal(b, m, deterministic)
}
func (dst *Datum_AssocPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Datum_AssocPair.Merge(dst, src)
}
func (m *Datum_AssocPair) XXX_Size() int {
	return xxx_messageInfo_Datum_AssocPair.Size(m)
}
func (m *Datum_AssocPair) XXX_DiscardUnknown() {
	xxx_messageInfo_Datum_AssocPair.DiscardUnknown(m)
}

var xxx_messageInfo_Datum_AssocPair proto.InternalMessageInfo

func (m *Datum_AssocPair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Datum_AssocPair) GetVal() *Datum {
	if m != nil {
		return m.Val
	}
	return nil
}

// A [Term] is either a piece of data (see **Datum** above), or an operator and
// its operands.  If you have a [Datum], it's stored in the member [datum].  If
// you have an operator, its positional arguments are stored in [args] and its
// optional arguments are stored in [optargs].
//
// A note about type signatures:
// We use the following notation to denote types:
//   arg1_type, arg2_type, argrest_type... -> result_type
// So, for example, if we have a function `avg` that takes any number of
// arguments and averages them, we might write:
//   NUMBER... -> NUMBER
// Or if we had a function that took one number modulo another:
//   NUMBER, NUMBER -> NUMBER
// Or a function that takes a table and a primary key of any Datum type, then
// retrieves the entry with that primary key:
//   Table, DATUM -> OBJECT
// Some arguments must be provided as literal values (and not the results of sub
// terms).  These are marked with a `!`.
// Optional arguments are specified within curly braces as argname `:` value
// type (e.x `{noreply:BOOL}`)
// Many RQL operations are polymorphic. For these, alternative type signatures
// are separated by `|`.
//
// The RQL type hierarchy is as follows:
//   Top
//     DATUM
//       NULL
//       BOOL
//       NUMBER
//       STRING
//       OBJECT
//         SingleSelection
//       ARRAY
//     Sequence
//       ARRAY
//       Stream
//         StreamSelection
//           Table
//     Database
//     Function
//     Ordering - used only by ORDER_BY
//     Pathspec -- an object, string, or array that specifies a path
//   Error
type Term struct {
	Type *Term_TermType `protobuf:"varint,1,opt,name=type,enum=Term_TermType" json:"type,omitempty"`
	// This is only used when type is DATUM.
	Datum                *Datum            `protobuf:"bytes,2,opt,name=datum" json:"datum,omitempty"`
	Args                 []*Term           `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`
	Optargs              []*Term_AssocPair `protobuf:"bytes,4,rep,name=optargs" json:"optargs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Term) Reset()         { *m = Term{} }
func (m *Term) String() string { return proto.CompactTextString(m) }
func (*Term) ProtoMessage()    {}
func (*Term) Descriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{6}
}
func (m *Term) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Term.Unmarshal(m, b)
}
func (m *Term) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Term.Marshal(b, m, deterministic)
}
func (dst *Term) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Term.Merge(dst, src)
}
func (m *Term) XXX_Size() int {
	return xxx_messageInfo_Term.Size(m)
}
func (m *Term) XXX_DiscardUnknown() {
	xxx_messageInfo_Term.DiscardUnknown(m)
}

var xxx_messageInfo_Term proto.InternalMessageInfo

func (m *Term) GetType() Term_TermType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Term_DATUM
}

func (m *Term) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *Term) GetArgs() []*Term {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Term) GetOptargs() []*Term_AssocPair {
	if m != nil {
		return m.Optargs
	}
	return nil
}

type Term_AssocPair struct {
	Key                  *string  `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Val                  *Term    `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Term_AssocPair) Reset()         { *m = Term_AssocPair{} }
func (m *Term_AssocPair) String() string { return proto.CompactTextString(m) }
func (*Term_AssocPair) ProtoMessage()    {}
func (*Term_AssocPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_ql2_e86fe8a8468b24a0, []int{6, 0}
}
func (m *Term_AssocPair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Term_AssocPair.Unmarshal(m, b)
}
func (m *Term_AssocPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Term_AssocPair.Marshal(b, m, deterministic)
}
func (dst *Term_AssocPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Term_AssocPair.Merge(dst, src)
}
func (m *Term_AssocPair) XXX_Size() int {
	return xxx_messageInfo_Term_AssocPair.Size(m)
}
func (m *Term_AssocPair) XXX_DiscardUnknown() {
	xxx_messageInfo_Term_AssocPair.DiscardUnknown(m)
}

var xxx_messageInfo_Term_AssocPair proto.InternalMessageInfo

func (m *Term_AssocPair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Term_AssocPair) GetVal() *Term {
	if m != nil {
		return m.Val
	}
	return nil
}

func init() {
	proto.RegisterType((*VersionDummy)(nil), "VersionDummy")
	proto.RegisterType((*Query)(nil), "Query")
	proto.RegisterType((*Query_AssocPair)(nil), "Query.AssocPair")
	proto.RegisterType((*Frame)(nil), "Frame")
	proto.RegisterType((*Backtrace)(nil), "Backtrace")
	proto.RegisterType((*Response)(nil), "Response")
	proto.RegisterType((*Datum)(nil), "Datum")
	proto.RegisterType((*Datum_AssocPair)(nil), "Datum.AssocPair")
	proto.RegisterType((*Term)(nil), "Term")
	proto.RegisterType((*Term_AssocPair)(nil), "Term.AssocPair")
	proto.RegisterEnum("VersionDummy_Version", VersionDummy_Version_name, VersionDummy_Version_value)
	proto.RegisterEnum("VersionDummy_Protocol", VersionDummy_Protocol_name, VersionDummy_Protocol_value)
	proto.RegisterEnum("Query_QueryType", Query_QueryType_name, Query_QueryType_value)
	proto.RegisterEnum("Frame_FrameType", Frame_FrameType_name, Frame_FrameType_value)
	proto.RegisterEnum("Response_ResponseType", Response_ResponseType_name, Response_ResponseType_value)
	proto.RegisterEnum("Response_ErrorType", Response_ErrorType_name, Response_ErrorType_value)
	proto.RegisterEnum("Response_ResponseNote", Response_ResponseNote_name, Response_ResponseNote_value)
	proto.RegisterEnum("Datum_DatumType", Datum_DatumType_name, Datum_DatumType_value)
	proto.RegisterEnum("Term_TermType", Term_TermType_name, Term_TermType_value)
}

func init() { proto.RegisterFile("ql2.proto", fileDescriptor_ql2_e86fe8a8468b24a0) }

var fileDescriptor_ql2_e86fe8a8468b24a0 = []byte{
	// 2492 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x5b, 0x70, 0x64, 0x45,
	0x19, 0xae, 0xc9, 0xcc, 0x64, 0x66, 0x3a, 0xd9, 0xec, 0xbf, 0x27, 0x0b, 0x84, 0x7b, 0x1c, 0x51,
	0x03, 0x8b, 0x5b, 0xbb, 0x01, 0x01, 0x51, 0x2c, 0x7b, 0xce, 0xe9, 0x99, 0xe9, 0xe4, 0x4c, 0xf7,
	0x49, 0x77, 0x9f, 0x64, 0x07, 0x2f, 0x87, 0x6c, 0x98, 0xc5, 0x65, 0x93, 0x4c, 0x38, 0x33, 0x8b,
	0x06, 0x6f, 0xab, 0x20, 0x0a, 0x88, 0x8a, 0x17, 0x54, 0x10, 0xc1, 0x0b, 0xe0, 0x05, 0x15, 0x4a,
	0x05, 0xbc, 0x80, 0x0b, 0x58, 0xe5, 0xab, 0x6f, 0x54, 0xf9, 0x24, 0x2f, 0x56, 0xf9, 0xe2, 0x8b,
	0x3e, 0x58, 0xee, 0x83, 0xd6, 0xff, 0x9f, 0x99, 0x49, 0x56, 0x28, 0x5f, 0x7c, 0x99, 0xf3, 0x7f,
	0xdf, 0xff, 0xf7, 0xed, 0xbf, 0x75, 0x0f, 0xab, 0xdc, 0xb6, 0x3e, 0x7f, 0x70, 0x2b, 0xed, 0xf6,
	0xbb, 0xd5, 0xfb, 0x72, 0x6c, 0x72, 0xb9, 0x93, 0xf6, 0x8e, 0x77, 0x37, 0x83, 0x93, 0x1b, 0x1b,
	0xdb, 0x55, 0xcd, 0x4a, 0x03, 0xec, 0x4d, 0xb2, 0xc2, 0xf2, 0xa1, 0xe4, 0x30, 0x3c, 0xfb, 0x8f,
	0xbb, 0xcf, 0xe4, 0x07, 0x68, 0x1e, 0x5e, 0xbb, 0xf3, 0xe5, 0x07, 0x4a, 0x03, 0x74, 0x15, 0xbc,
	0xf8, 0xc7, 0x57, 0xcf, 0x14, 0x07, 0xe8, 0x6a, 0x78, 0xec, 0x4f, 0x4f, 0x9f, 0x2a, 0x10, 0x3a,
	0x9c, 0x1c, 0x82, 0x57, 0xce, 0xdc, 0xfb, 0x44, 0xbe, 0x7a, 0x05, 0x2b, 0x47, 0xb8, 0xd4, 0x5a,
	0x77, 0xdd, 0x03, 0x56, 0x8e, 0x8c, 0x76, 0xba, 0x16, 0xd7, 0xe1, 0xa5, 0x7f, 0xfe, 0xfb, 0xf9,
	0x31, 0xb4, 0x5d, 0xb0, 0x5a, 0xc1, 0x1f, 0x5e, 0x7b, 0xfc, 0xef, 0xa5, 0xea, 0x9d, 0x79, 0x56,
	0x5c, 0x3a, 0xd9, 0x49, 0xb7, 0xbd, 0xcb, 0x58, 0xa1, 0xbf, 0xbd, 0xd5, 0x99, 0xc9, 0xcd, 0xe6,
	0xe6, 0xa6, 0xe6, 0xe1, 0x20, 0xb1, 0xd9, 0xaf, 0xdb, 0xde, 0xea, 0x18, 0xd2, 0x7a, 0x17, 0xb2,
	0xe2, 0x6d, 0x48, 0xcd, 0x8c, 0xcd, 0xe6, 0xe6, 0x26, 0xe6, 0x8b, 0x07, 0x5d, 0x27, 0xdd, 0x30,
	0x19, 0xe7, 0xed, 0x67, 0xc5, 0x7e, 0xf7, 0x44, 0x67, 0x73, 0x26, 0x3f, 0x9b, 0x9b, 0xcb, 0x9b,
	0x0c, 0x78, 0x87, 0x18, 0xe8, 0x9a, 0xd5, 0xa1, 0x70, 0x22, 0xd9, 0xec, 0xa6, 0x9d, 0xad, 0xf5,
	0xed, 0x99, 0xc2, 0x6c, 0x6e, 0xae, 0x7c, 0x7d, 0xf1, 0xd8, 0xea, 0x7a, 0xaf, 0x63, 0xf6, 0x0e,
	0xd5, 0x2a, 0xd3, 0x7a, 0x07, 0xd8, 0xd4, 0xea, 0xda, 0x5a, 0x67, 0xab, 0xdf, 0x4b, 0xd2, 0xe4,
	0xd6, 0x5e, 0x77, 0x73, 0xa6, 0xb8, 0xdb, 0x7e, 0x72, 0xa0, 0x34, 0x0b, 0xbd, 0xee, 0xa6, 0x77,
	0x2d, 0x9b, 0xba, 0x65, 0xbd, 0x7b, 0x74, 0x75, 0x3d, 0xe9, 0x6e, 0xf5, 0x57, 0xd3, 0x5b, 0x7a,
	0x33, 0xe3, 0xb3, 0xf9, 0xb9, 0x89, 0xd1, 0x09, 0x78, 0xaf, 0xd7, 0x5d, 0x8b, 0x56, 0x8f, 0xa7,
	0x66, 0x4f, 0x66, 0xa7, 0x33, 0xb3, 0x0b, 0xae, 0x61, 0x95, 0x91, 0xce, 0x03, 0x96, 0x3f, 0xd1,
	0xd9, 0xa6, 0xc3, 0x57, 0x0c, 0x8a, 0xde, 0x79, 0x2c, 0x7f, 0xfb, 0xea, 0xfa, 0xd9, 0xe7, 0x44,
	0xa6, 0xba, 0xc4, 0x2a, 0x23, 0xaf, 0x78, 0x15, 0x56, 0xb4, 0x8e, 0x1b, 0x07, 0x39, 0x6f, 0x92,
	0x95, 0x7d, 0xad, 0x9c, 0x54, 0xb1, 0x80, 0x31, 0xaf, 0xcc, 0x0a, 0xd6, 0xe9, 0x08, 0xf2, 0x1e,
	0xb0, 0x49, 0xa5, 0x8d, 0x88, 0xc2, 0x76, 0xb2, 0xc2, 0xa5, 0x83, 0x82, 0xb7, 0x97, 0x4d, 0x58,
	0x61, 0x96, 0x85, 0x49, 0xa4, 0xaa, 0x6b, 0x28, 0x56, 0xb7, 0x58, 0xb1, 0x9e, 0xae, 0x6e, 0x74,
	0x5e, 0x17, 0x04, 0x62, 0xb3, 0xdf, 0x5d, 0x41, 0x00, 0x96, 0xdf, 0xea, 0xf6, 0x68, 0x6b, 0x79,
	0x83, 0x22, 0x32, 0xdd, 0xad, 0x3e, 0xf9, 0xbd, 0x62, 0x50, 0xac, 0x5e, 0xcc, 0x2a, 0xa3, 0x61,
	0x5e, 0x89, 0xe5, 0x23, 0x6d, 0x21, 0x87, 0x82, 0x8e, 0x1c, 0x8c, 0x55, 0x0f, 0xb0, 0x4a, 0x6d,
	0x75, 0xed, 0x44, 0x3f, 0x5d, 0x5d, 0xeb, 0x78, 0x97, 0xb0, 0xf1, 0x63, 0x68, 0xdb, 0x9b, 0xc9,
	0x91, 0xeb, 0xc6, 0xb3, 0x15, 0xcd, 0x80, 0xad, 0xfe, 0xb5, 0xc8, 0xca, 0xa6, 0xd3, 0xdb, 0xea,
	0x6e, 0xf6, 0x3a, 0xde, 0x15, 0x67, 0x6d, 0xf1, 0xdc, 0x83, 0x43, 0xc5, 0x48, 0xd8, 0xb5, 0xd1,
	0x79, 0xc6, 0x3a, 0x69, 0xda, 0x4d, 0x13, 0x1a, 0x51, 0xa2, 0x11, 0xd3, 0x3b, 0x23, 0x04, 0xea,
	0xc8, 0xbc, 0xd2, 0x19, 0x8a, 0xde, 0x95, 0xac, 0xb8, 0xd9, 0xed, 0x77, 0xb2, 0x30, 0xbe, 0xe1,
	0x02, 0xaa, 0xdb, 0xef, 0x98, 0xcc, 0x68, 0x27, 0xe5, 0xc6, 0x76, 0xa7, 0x5c, 0x95, 0x95, 0xd3,
	0x81, 0xf1, 0x4c, 0x7e, 0x70, 0xa4, 0x60, 0xb5, 0x7f, 0x72, 0xc3, 0x8c, 0x78, 0x6f, 0x8e, 0x55,
	0x8e, 0x0e, 0x3d, 0x40, 0xf9, 0x38, 0x31, 0xcf, 0x0e, 0x8e, 0x7c, 0x62, 0x76, 0x94, 0xde, 0x2c,
	0x2b, 0x6d, 0xa5, 0xdd, 0x63, 0xc7, 0xd7, 0x3b, 0x94, 0x87, 0x3b, 0x93, 0x0d, 0xe9, 0xea, 0x93,
	0x39, 0x36, 0xb9, 0xfb, 0xf8, 0x18, 0x73, 0x1b, 0xfb, 0xbe, 0xb0, 0x36, 0xe1, 0x4e, 0xb7, 0x20,
	0xe7, 0xed, 0x67, 0x30, 0x64, 0xac, 0x58, 0x8a, 0x85, 0xf2, 0x31, 0x4b, 0xa6, 0xd9, 0xde, 0x21,
	0x1b, 0x71, 0xe3, 0x24, 0x0f, 0x21, 0xef, 0xed, 0x63, 0x7b, 0x30, 0x51, 0x12, 0x5f, 0xb7, 0x22,
	0x2c, 0x8b, 0x37, 0xc8, 0x18, 0x5c, 0xc0, 0x0f, 0xa5, 0x50, 0x2e, 0x11, 0xc6, 0x68, 0x03, 0x80,
	0xa3, 0x70, 0x80, 0x0c, 0xc5, 0x80, 0xda, 0x87, 0x94, 0x89, 0x95, 0x93, 0xad, 0x21, 0xe5, 0x55,
	0x9f, 0xca, 0xb1, 0xca, 0xc8, 0xed, 0xde, 0x14, 0x2b, 0x4b, 0xe5, 0x84, 0x51, 0x3c, 0x84, 0xd3,
	0x77, 0xdd, 0xe0, 0xed, 0x67, 0x53, 0x46, 0x58, 0x1d, 0x1b, 0x5f, 0x24, 0xa1, 0x6c, 0x49, 0x07,
	0xa7, 0xee, 0xb9, 0xc3, 0xf3, 0xd8, 0xc4, 0x52, 0x2c, 0x4c, 0x3b, 0x09, 0x75, 0x43, 0xfa, 0x70,
	0xfa, 0xfe, 0xe7, 0xf0, 0x38, 0x7b, 0x94, 0x56, 0x89, 0x38, 0x22, 0xad, 0xa3, 0xb3, 0xfc, 0xf9,
	0xa1, 0x17, 0x72, 0x1e, 0xb0, 0x8a, 0x8e, 0x92, 0x3a, 0x97, 0xa1, 0x08, 0xe0, 0xb1, 0x47, 0xff,
	0x95, 0xf3, 0xce, 0x63, 0xa0, 0xa3, 0x44, 0xaa, 0x40, 0x38, 0x61, 0x5a, 0x52, 0x71, 0x27, 0xe0,
	0xf4, 0x53, 0xa7, 0xc6, 0xbc, 0x09, 0x56, 0x88, 0xad, 0x30, 0x70, 0xfa, 0xc1, 0x67, 0xc6, 0xd0,
	0x2a, 0x42, 0xb5, 0xb5, 0x12, 0x27, 0xa5, 0xbd, 0x9e, 0x7a, 0xf8, 0x6f, 0x63, 0xd5, 0xad, 0x1d,
	0xbf, 0x62, 0xd4, 0xf1, 0x44, 0x43, 0xef, 0x25, 0x75, 0x21, 0x02, 0xc8, 0x79, 0x7b, 0x58, 0x05,
	0x5d, 0x9c, 0x41, 0x9c, 0x6a, 0x5a, 0x9b, 0x40, 0x98, 0xa4, 0xd6, 0xce, 0x8e, 0x90, 0x29, 0xa8,
	0x0c, 0x63, 0x25, 0xb5, 0x12, 0x41, 0xc6, 0x14, 0xd0, 0xf9, 0x52, 0xf9, 0x61, 0x1c, 0x08, 0x9b,
	0x58, 0xc7, 0x9d, 0xb0, 0x50, 0xac, 0xbe, 0x3a, 0xc6, 0x8a, 0x14, 0xdd, 0xd7, 0xd5, 0x22, 0xb1,
	0xd9, 0xef, 0xae, 0x14, 0x3f, 0x87, 0x8d, 0xa7, 0xc9, 0xd1, 0x6e, 0x37, 0xeb, 0x14, 0x65, 0x53,
	0x4c, 0x6b, 0xdd, 0xee, 0xba, 0x37, 0xcd, 0x8a, 0x69, 0xb2, 0x79, 0x72, 0x83, 0x4a, 0x32, 0x67,
	0x0a, 0xa9, 0x3a, 0xb9, 0x91, 0x91, 0xbd, 0x7e, 0x4a, 0xe9, 0x56, 0x31, 0x85, 0xd4, 0xf6, 0x53,
	0xef, 0x52, 0x56, 0x4a, 0x93, 0xd5, 0x34, 0x5d, 0xdd, 0x9e, 0x29, 0x9e, 0x95, 0xaa, 0xe3, 0x29,
	0x47, 0xd6, 0x3b, 0xc0, 0xca, 0x69, 0xd2, 0x3d, 0x7a, 0x6b, 0x67, 0xad, 0x3f, 0x6a, 0x6d, 0xd9,
	0x5e, 0x76, 0x5a, 0x5b, 0x29, 0xd5, 0x64, 0x70, 0xc1, 0xb5, 0xff, 0xbb, 0xa9, 0xcd, 0xec, 0x6e,
	0x6a, 0xc3, 0x85, 0xa8, 0xab, 0xdd, 0xc4, 0x2a, 0xa3, 0xa3, 0x79, 0x8c, 0x8d, 0x9b, 0x44, 0xc5,
	0x61, 0x08, 0xb9, 0x4c, 0xae, 0x69, 0x1d, 0xc2, 0x18, 0x76, 0x3b, 0xe4, 0x5b, 0x90, 0xcf, 0x44,
	0xeb, 0x0c, 0x14, 0xbc, 0x09, 0x56, 0x32, 0x09, 0x37, 0x86, 0xb7, 0x01, 0x2f, 0xa6, 0xb2, 0x49,
	0x74, 0x6d, 0x41, 0xf8, 0x0e, 0xc6, 0xb3, 0xc1, 0x74, 0xdd, 0x94, 0xaa, 0x7f, 0xd9, 0xcf, 0x0a,
	0xd8, 0x45, 0xbd, 0xea, 0x59, 0x8e, 0x9d, 0xa2, 0xd6, 0x4a, 0x3f, 0xbb, 0xdc, 0x7a, 0x11, 0x2b,
	0xde, 0x8c, 0xdb, 0xf9, 0xaf, 0xad, 0x66, 0xa4, 0x77, 0x3e, 0x2b, 0x50, 0xa7, 0xcf, 0x6a, 0x7b,
	0xd0, 0x9c, 0x89, 0xf2, 0x2e, 0x67, 0xa5, 0xe1, 0x3d, 0x50, 0x20, 0xed, 0xde, 0x6c, 0xfe, 0x5d,
	0xbe, 0xea, 0xfe, 0x9f, 0x17, 0xc0, 0x23, 0xd3, 0xac, 0x3c, 0xdc, 0x2e, 0xfa, 0x21, 0xe0, 0x2e,
	0xc6, 0x12, 0x9f, 0x62, 0xac, 0xc5, 0x17, 0xc5, 0xc0, 0x15, 0x78, 0xd3, 0x96, 0x09, 0xeb, 0xda,
	0x02, 0xe4, 0xb1, 0xf5, 0x2e, 0x73, 0x03, 0x0c, 0xcd, 0x16, 0xf8, 0x32, 0xb7, 0xbe, 0x91, 0x91,
	0x83, 0x09, 0xaf, 0xc2, 0x0a, 0x71, 0x2c, 0x03, 0xf8, 0x61, 0x0e, 0xc5, 0xa6, 0x73, 0x11, 0x7c,
	0x13, 0xc5, 0x62, 0x56, 0x07, 0x93, 0x98, 0xb9, 0xb2, 0x15, 0x85, 0xd2, 0x97, 0x2e, 0xc1, 0x29,
	0xf6, 0x78, 0xe3, 0x6c, 0x2c, 0xa8, 0xc1, 0x14, 0x1a, 0x39, 0x5e, 0x0b, 0x05, 0xec, 0xc5, 0xe9,
	0x1b, 0xc2, 0x01, 0x60, 0x34, 0x1a, 0xc2, 0x25, 0x3c, 0x0c, 0x41, 0xa1, 0xa1, 0x58, 0x82, 0x7d,
	0xf8, 0x55, 0x02, 0x3c, 0xfc, 0x86, 0x0e, 0xa6, 0xe9, 0x2b, 0x60, 0x3f, 0x7e, 0x1b, 0x0e, 0xce,
	0xa1, 0xaf, 0x80, 0x73, 0x71, 0x16, 0xa5, 0x1d, 0x9c, 0x87, 0x02, 0x0f, 0x02, 0x98, 0x41, 0xc1,
	0xc6, 0x35, 0x38, 0x1f, 0x85, 0x56, 0x1c, 0xc2, 0x05, 0x28, 0x04, 0x72, 0x19, 0x2e, 0x24, 0x46,
	0x07, 0x70, 0x91, 0xc7, 0x58, 0xb1, 0x1e, 0x6a, 0x6d, 0xe0, 0x39, 0x3a, 0x82, 0x2f, 0x64, 0x08,
	0xcf, 0x63, 0xe6, 0x14, 0x8d, 0x8e, 0x55, 0x00, 0xbf, 0xa2, 0x2c, 0xe2, 0x51, 0x24, 0x54, 0x00,
	0x17, 0xe3, 0x0e, 0x23, 0x23, 0x08, 0x44, 0xe8, 0x8d, 0x40, 0xd6, 0xeb, 0xc2, 0x50, 0x17, 0x49,
	0x10, 0x5b, 0xe1, 0x12, 0xa9, 0xac, 0x30, 0x0e, 0x8e, 0x50, 0xdf, 0x24, 0xec, 0x84, 0xb1, 0xc2,
	0x77, 0x52, 0x2b, 0x68, 0x63, 0xd1, 0x23, 0x4b, 0x05, 0x0d, 0x37, 0x7a, 0x1e, 0x9b, 0x42, 0xb8,
	0x6b, 0xa2, 0xf7, 0xd1, 0xcd, 0x1c, 0x4a, 0x5f, 0xc0, 0x25, 0x74, 0x17, 0x2f, 0xca, 0x08, 0xea,
	0x48, 0x66, 0x7d, 0xad, 0x81, 0x0b, 0xe9, 0x7a, 0xdd, 0x0a, 0x67, 0x13, 0x5d, 0x87, 0x95, 0xe1,
	0xf5, 0xcd, 0xa5, 0xb2, 0xf0, 0x01, 0x5c, 0x00, 0xbd, 0x58, 0x97, 0x22, 0x0c, 0xe0, 0x52, 0x9c,
	0x61, 0x51, 0xb4, 0x2d, 0x7c, 0xd0, 0x9b, 0x60, 0xe3, 0xcb, 0x3c, 0x8c, 0x85, 0x85, 0x5f, 0xe7,
	0x10, 0x0c, 0x52, 0xfd, 0x8b, 0x14, 0xfe, 0x26, 0xb7, 0xd9, 0x10, 0x0b, 0xb3, 0xd8, 0xb3, 0x57,
	0xa4, 0x6b, 0x0e, 0x89, 0x9b, 0x70, 0xf1, 0x28, 0x8c, 0xfd, 0x45, 0x78, 0x13, 0xba, 0x00, 0x75,
	0x3a, 0x76, 0x50, 0x45, 0xbe, 0x25, 0x4c, 0x43, 0xc0, 0x9b, 0xbd, 0x73, 0x99, 0x57, 0x13, 0x6e,
	0x45, 0x08, 0x95, 0x04, 0x22, 0x32, 0xc2, 0xe7, 0x4e, 0x04, 0x70, 0x99, 0x37, 0xc9, 0x4a, 0x03,
	0x1e, 0x9e, 0xcd, 0x4a, 0x52, 0x04, 0xb1, 0x2f, 0xe0, 0x2d, 0x14, 0x04, 0x1e, 0xc1, 0x5b, 0xd1,
	0xf1, 0x75, 0x1d, 0x06, 0xf0, 0x1b, 0xd2, 0xd7, 0x65, 0xe8, 0x84, 0x81, 0xb7, 0xe1, 0xae, 0x7c,
	0xad, 0x7c, 0xee, 0x12, 0x34, 0x9b, 0xc3, 0x63, 0x0e, 0xfb, 0x23, 0x5c, 0x8e, 0x28, 0x90, 0xd6,
	0x49, 0xe5, 0x3b, 0xb8, 0x02, 0x37, 0xe2, 0xeb, 0x58, 0x39, 0x38, 0x80, 0x0a, 0x69, 0x13, 0xd1,
	0x8a, 0x5c, 0x1b, 0x96, 0x51, 0x91, 0xb9, 0xfa, 0x4a, 0xca, 0x10, 0xd7, 0x84, 0xb7, 0xd3, 0x96,
	0x0c, 0xf7, 0x17, 0x85, 0x83, 0x1f, 0xd1, 0xe1, 0xa5, 0x52, 0xc2, 0x24, 0x0b, 0x5a, 0x2a, 0x38,
	0x44, 0xde, 0x8d, 0xdd, 0x10, 0x1f, 0xc6, 0x03, 0x8b, 0xa5, 0x0c, 0xcc, 0xe3, 0x1c, 0x37, 0xca,
	0x08, 0x9a, 0x94, 0x21, 0x5c, 0x35, 0x04, 0xfc, 0x84, 0xfa, 0x78, 0x16, 0xf4, 0x84, 0x3b, 0x30,
	0x08, 0x03, 0x41, 0x6f, 0x46, 0xee, 0xc0, 0x22, 0xf4, 0x9b, 0x68, 0x8a, 0xd0, 0x51, 0xfc, 0xb1,
	0x22, 0x08, 0xc6, 0xa4, 0xd5, 0x02, 0x6f, 0x2d, 0xa7, 0xe1, 0x2a, 0x5c, 0xcc, 0xb5, 0x23, 0x81,
	0x71, 0xbd, 0x1a, 0x9d, 0x11, 0x47, 0x01, 0xde, 0x3b, 0xef, 0x40, 0x39, 0x9b, 0x14, 0xae, 0xa1,
	0xae, 0x25, 0xa2, 0x90, 0xfb, 0x02, 0xae, 0x45, 0xc5, 0x20, 0xe3, 0xae, 0xa3, 0x95, 0x6b, 0x89,
	0x6f, 0x04, 0x8e, 0x79, 0x27, 0xda, 0x05, 0xb5, 0x24, 0x30, 0x3a, 0x82, 0xeb, 0x07, 0x20, 0x94,
	0xd6, 0xc1, 0xbb, 0xb0, 0x2e, 0xa9, 0xfa, 0x86, 0xb6, 0xef, 0xc6, 0x53, 0x67, 0x0c, 0x99, 0xdf,
	0xb0, 0x83, 0x69, 0xc4, 0x7b, 0x30, 0x5f, 0x7c, 0xad, 0xea, 0xb2, 0x01, 0x3f, 0xa5, 0xe4, 0xc1,
	0x5b, 0x27, 0xb6, 0xf0, 0x33, 0x2a, 0x1b, 0x7a, 0x1c, 0x3e, 0x83, 0x97, 0xe8, 0x84, 0x11, 0x99,
	0x59, 0x6c, 0x04, 0x3c, 0x8d, 0xce, 0xad, 0x18, 0x51, 0xe3, 0x21, 0xc7, 0xcc, 0xfe, 0x39, 0x19,
	0xdb, 0xb6, 0xf2, 0xe1, 0x5e, 0xaa, 0xb1, 0x86, 0xe1, 0xca, 0xc1, 0x6f, 0x73, 0xd4, 0x27, 0x54,
	0x20, 0x8e, 0x0c, 0xf7, 0xb3, 0x98, 0x45, 0x05, 0x19, 0xda, 0x4f, 0xb8, 0x83, 0x69, 0x3f, 0x2d,
	0x6f, 0xdf, 0x70, 0xc4, 0x60, 0x23, 0xf7, 0xe5, 0xbc, 0xbd, 0x43, 0x13, 0xda, 0xce, 0xe7, 0x73,
	0x3b, 0x36, 0x46, 0x28, 0xde, 0x12, 0xf0, 0xad, 0x9c, 0x37, 0x9d, 0x95, 0xdb, 0x8a, 0x91, 0x4e,
	0x24, 0x4d, 0xad, 0x17, 0xe1, 0x05, 0x22, 0x1b, 0x67, 0x93, 0x2f, 0xe2, 0x19, 0x4b, 0xf5, 0x58,
	0xf9, 0xd8, 0x8c, 0xde, 0x8b, 0x4e, 0xae, 0x19, 0xae, 0xfc, 0x26, 0x70, 0x6c, 0x38, 0xda, 0x40,
	0x8d, 0xfa, 0x8c, 0x0a, 0xc0, 0xc7, 0x84, 0xab, 0x6b, 0x93, 0x08, 0xee, 0x37, 0x21, 0xc0, 0x7a,
	0xc3, 0x71, 0x20, 0xc8, 0xc0, 0xfa, 0x20, 0x91, 0x0a, 0x84, 0xf5, 0x61, 0x01, 0x25, 0x7a, 0x05,
	0x69, 0xaa, 0x1c, 0xee, 0xfc, 0x26, 0xac, 0xa2, 0x37, 0xe3, 0xc8, 0xe7, 0x56, 0xc0, 0xfd, 0x98,
	0x4b, 0xe5, 0x40, 0xaf, 0x28, 0x82, 0x5f, 0xa0, 0x7a, 0xb0, 0x1c, 0xdf, 0x52, 0xb0, 0x44, 0x11,
	0x14, 0x75, 0x1e, 0x87, 0x0e, 0xde, 0x8f, 0x33, 0xd1, 0xe5, 0x74, 0x14, 0x69, 0x69, 0xf5, 0x75,
	0xd7, 0x1c, 0x3a, 0x0c, 0x6b, 0x14, 0x36, 0x9d, 0x0c, 0xf1, 0xcd, 0x88, 0x45, 0xa4, 0xfd, 0x66,
	0x82, 0x4f, 0x29, 0xa0, 0x57, 0x88, 0xd3, 0xc9, 0x2e, 0xea, 0x58, 0xd6, 0x38, 0x57, 0xe0, 0x16,
	0xac, 0x7a, 0xa9, 0x88, 0xbd, 0x51, 0x2b, 0x01, 0x1f, 0xa2, 0x9c, 0x8b, 0x8d, 0x54, 0x0d, 0x38,
	0x4e, 0x67, 0xc0, 0xc8, 0xdc, 0x8a, 0x66, 0xf4, 0x2e, 0xd3, 0xf5, 0x24, 0xe0, 0x6d, 0xf8, 0x04,
	0x9e, 0x7f, 0x34, 0xe8, 0x93, 0x18, 0xe1, 0xb6, 0xe0, 0x06, 0x4e, 0x51, 0x84, 0x5b, 0x1a, 0x4b,
	0xee, 0x53, 0x39, 0xaf, 0xcc, 0xf2, 0x68, 0xfd, 0x69, 0x4a, 0x92, 0x80, 0xb7, 0x71, 0xf8, 0x8a,
	0x10, 0x8b, 0x70, 0xe7, 0x6e, 0x86, 0x46, 0xde, 0x45, 0x23, 0x9b, 0x3a, 0x36, 0x16, 0x3e, 0x83,
	0x7f, 0x4e, 0x4a, 0x2d, 0xa9, 0x62, 0x7c, 0xe3, 0xdc, 0x4d, 0xc8, 0x62, 0x8a, 0x05, 0x16, 0x3e,
	0x4b, 0xe9, 0x44, 0xa7, 0xf8, 0x1c, 0x79, 0xaa, 0xa5, 0x15, 0xae, 0x71, 0x82, 0xaa, 0x28, 0x16,
	0x16, 0xc1, 0x3a, 0x16, 0xc5, 0x8a, 0x08, 0x54, 0x06, 0x37, 0x68, 0xb7, 0xcd, 0xd8, 0x10, 0xda,
	0xa4, 0x7e, 0x63, 0x24, 0xca, 0x5d, 0xd4, 0x58, 0xee, 0x62, 0x83, 0x68, 0x8b, 0x3c, 0x1f, 0xd3,
	0x7c, 0xb7, 0xe1, 0x7c, 0x0b, 0x5c, 0xc5, 0xdc, 0xb4, 0x21, 0xa5, 0x70, 0x8b, 0x9a, 0x21, 0xd4,
	0xcb, 0xe2, 0x68, 0xfc, 0x26, 0xf4, 0x51, 0xe4, 0x91, 0x91, 0x21, 0x9c, 0xcc, 0x5a, 0x5b, 0x1b,
	0x6e, 0xa7, 0x30, 0xc5, 0x4a, 0xc0, 0x87, 0x33, 0x29, 0x6c, 0xc3, 0x47, 0xe8, 0x42, 0x89, 0x1b,
	0xb1, 0x75, 0xb0, 0x9d, 0xdd, 0x06, 0x91, 0x13, 0xad, 0x9a, 0x30, 0x70, 0x07, 0x2e, 0xa4, 0x7d,
	0xa7, 0x11, 0x7c, 0x14, 0x17, 0x52, 0x7a, 0x39, 0x53, 0x7d, 0x8c, 0xfa, 0x9d, 0xf0, 0x33, 0xf4,
	0x71, 0x74, 0x43, 0x28, 0x9d, 0x30, 0x3c, 0x84, 0x7b, 0x06, 0xa5, 0xa4, 0xe3, 0x08, 0xbe, 0x44,
	0x8e, 0xb6, 0x71, 0x0b, 0x1e, 0x20, 0x89, 0x2f, 0x37, 0xe0, 0xcb, 0x24, 0xb5, 0xa4, 0x82, 0xaf,
	0x64, 0x12, 0x3f, 0x02, 0x5f, 0xa5, 0x31, 0xd8, 0x87, 0x1c, 0x7c, 0x8d, 0x9c, 0x1a, 0xab, 0x6c,
	0x86, 0x07, 0xa9, 0xba, 0x0d, 0x57, 0x81, 0x6e, 0xc1, 0xd7, 0x49, 0x95, 0x75, 0x2f, 0x0b, 0xdf,
	0x20, 0x7f, 0x73, 0xd3, 0xb0, 0xf0, 0x10, 0x59, 0xd5, 0xa4, 0x42, 0x27, 0x3c, 0x4c, 0x56, 0x0d,
	0xa1, 0x29, 0x21, 0x1f, 0xa1, 0x42, 0x74, 0x3a, 0x19, 0x12, 0xdf, 0xa6, 0xb5, 0x22, 0x2d, 0x95,
	0x83, 0x47, 0x69, 0x8a, 0x50, 0x2a, 0x01, 0x8f, 0xd1, 0xa8, 0x48, 0x87, 0xed, 0x86, 0x56, 0xf0,
	0x9d, 0x2c, 0xf3, 0xa5, 0x75, 0xd4, 0x29, 0xbe, 0x3b, 0xa8, 0xe6, 0xc1, 0xcd, 0x69, 0xe1, 0x7b,
	0xa4, 0x1f, 0xbe, 0x79, 0xe1, 0xfb, 0xb4, 0xbe, 0x2f, 0x8d, 0x1f, 0x0a, 0x78, 0x3c, 0xe7, 0x9d,
	0xc3, 0xa0, 0x71, 0xd6, 0x55, 0xab, 0x1a, 0xf0, 0x04, 0xad, 0x55, 0x97, 0x61, 0x08, 0x4f, 0x52,
	0x8e, 0xa1, 0x85, 0x12, 0xdc, 0x08, 0xeb, 0xe0, 0x07, 0xc4, 0x0c, 0x56, 0x4f, 0xf0, 0x99, 0xf0,
	0x63, 0xea, 0x03, 0x4e, 0xd3, 0x9b, 0x0f, 0x9f, 0x87, 0x38, 0xc7, 0x53, 0xb4, 0x4e, 0x4b, 0xaa,
	0x65, 0x1e, 0xc2, 0x2f, 0x32, 0xc0, 0x8f, 0x20, 0xf8, 0x25, 0x6d, 0xbf, 0x26, 0x5d, 0x82, 0x4d,
	0xe0, 0x77, 0x03, 0x7f, 0xb8, 0x44, 0x1b, 0x38, 0x3d, 0x52, 0x1d, 0xd1, 0x06, 0x5e, 0x1a, 0x21,
	0x7c, 0x9e, 0xbc, 0x3c, 0x42, 0x96, 0x87, 0xf0, 0xca, 0x2e, 0x64, 0xe0, 0xf7, 0xb9, 0xff, 0x04,
	0x00, 0x00, 0xff, 0xff, 0x00, 0xe8, 0xb7, 0x56, 0x6d, 0x11, 0x00, 0x00,
}
